PROJECT FLOW OVERVIEW:
======================
The Federated Drug Trial Eligibility Screener is a privacy-preserving federated learning system.
It uses a FastAPI backend to coordinate the learning process, a React frontend for the user interface, and an Ethereum blockchain (via Ganache) to log training metadata immutably.

1. Frontend (React): Users interact with the system to start federated learning and view logs.
2. Backend (FastAPI): Exposes endpoints to control FL rounds and fetch metrics.
3. Federated Learning (Flower): Distributed training on client data without sharing raw patient data.
4. Blockchain (Ethereum): Smart contracts log metadata of the training process.


PROJECT STRUCTURE:
==================
./
    .env
    .gitignore
    commands.txt
    database.py
    data_utils.py
    dump_code.py
    model.py
    preprocessing.py
    project_structure_code.txt
    README.md
    requirements.txt
    run_backend.py
    api/
        main.py
        __init__.py
    blockchain/
        AuditLogger.sol
        FederatedTrainingLogger.sol
        logger.py
        __init__.py
    clients/
        client.py
        __init__.py
    fl_server/
        server.py
        __init__.py
    frontend/
        .env
        .eslintrc.json
        index.html
        package.json
        postcss.config.js
        README.md
        tailwind.config.js
        vite.config.js
        src/
            App.jsx
            index.css
            main.jsx
            components/
                BlockchainTable.jsx
                LoginPage.jsx
                Overview.jsx
                PatientsManager.jsx
                TrialsViewer.jsx
                ui/
                    Button.jsx
                    Card.jsx
                    index.js
                    Skeleton.jsx
                    StatusBadge.jsx
                    ThemeToggle.jsx
                    Toast.jsx
            hooks/
                useBlockchainLogs.js
                useTrainingData.js
            services/
                apiService.js
            stores/
                themeStore.js
            utils/
                motionVariants.js
    scripts/
        assign_hospitals.py
        seed_personal_details.py
        __init__.py


PROJECT CODE:
==================


================================================================================
--- FILE: .\.env ---
================================================================================
MONGO_URI=mongodb+srv://yb15313037_db_user:D09J5gpczE2QAAD8@cluster0.oxujjgd.mongodb.net/
MONGO_DB_NAME=federated_screener


================================================================================
--- FILE: .\.gitignore ---
================================================================================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv/
.venv*/
ENV/
pip-log.txt
pip-delete-this-directory.txt
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
*.egg-info/

# Node
node_modules/
npm-debug.log
yarn-error.log
.next/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Environment
.env
.env.local
.env.*.local

# Logs
*.log

# OS
Thumbs.db

# Large data files
medical_data.json
mimic_adapted.csv

# Uploads
uploads/

# Build outputs
frontend/dist/
frontend/.vite/

# Temp files
PROJECT_STRUCTURE_AND_CODE.txt
temp_patch.txt


================================================================================
--- FILE: .\commands.txt ---
================================================================================
To run the Federated Drug Trial Eligibility Screener, you need to open three separate terminal windows (PowerShell or Command Prompt) and run the following commands.

Note: Make sure you have the generated `.env` files in both the root folder and the `frontend` folder for the database connections and API URLs to work properly.

---

### Terminal 1: Start the Blockchain (Ganache)
Open a terminal in the main project folder (`Federated-Drug-Trial-Eligibility-Screener-main`) and run:
npx ganache

### Terminal 2: Start the Python Backend
Open a second terminal in the main project folder (`Federated-Drug-Trial-Eligibility-Screener-main`) and run:
.\.venv311\Scripts\python.exe -m uvicorn api.main:app --host 0.0.0.0 --port 8002

### Terminal 3: Start the React Frontend
Open a third terminal in the main project folder, navigate to the `frontend` directory, and start the development server:
cd frontend
npm run dev


================================================================================
--- FILE: .\database.py ---
================================================================================
"""
MongoDB database layer for Federated Drug Trial Eligibility Screener.

Collections:
  - patients        : patient medical records
  - audit_logs      : blockchain audit trail entries
  - training_logs   : federated learning training round logs
  - hospitals       : hospital login credentials
  - trials          : drug trial definitions

Uses Motor (async MongoDB driver) for FastAPI compatibility and
PyMongo (sync) for startup seeding and blockchain logger.
"""

import os
import time
import json
import logging
from datetime import datetime
from typing import List, Dict, Any, Optional
import dotenv
import certifi
from motor.motor_asyncio import AsyncIOMotorClient
from pymongo import MongoClient, ASCENDING, DESCENDING
from pymongo.errors import BulkWriteError

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
dotenv.load_dotenv()  # Load from .env if available
MONGO_URI = (os.getenv("MONGO_URI") or "").strip()
DB_NAME = (os.getenv("MONGO_DB_NAME") or "").strip()

logger = logging.getLogger("database")
if not logger.handlers:
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter("[DATABASE] %(levelname)s: %(message)s"))
    logger.addHandler(handler)
logger.setLevel(logging.INFO)

# ---------------------------------------------------------------------------
# Singleton clients (created once at module import)
# ---------------------------------------------------------------------------
_async_client: Optional[AsyncIOMotorClient] = None
_sync_client: Optional[MongoClient] = None


def get_async_client() -> AsyncIOMotorClient:
    global _async_client
    if _async_client is None:
        _async_client = AsyncIOMotorClient(MONGO_URI, tlsCAFile=certifi.where())
    return _async_client


def get_sync_client() -> MongoClient:
    global _sync_client
    if _sync_client is None:
        _sync_client = MongoClient(MONGO_URI, tlsCAFile=certifi.where())
    return _sync_client


def get_async_db():
    return get_async_client()[DB_NAME]


def get_sync_db():
    return get_sync_client()[DB_NAME]


# ---------------------------------------------------------------------------
# Index creation (called once at startup)
# ---------------------------------------------------------------------------
def ensure_indexes():
    """Create indexes for fast queries."""
    db = get_sync_db()
    try:
        db.patients.create_index([("patient_id", ASCENDING)], unique=False)
        db.patients.create_index([("disease", ASCENDING)])
        db.patients.create_index([("age", ASCENDING)])
        db.patients.create_index([("gender", ASCENDING)])
        db.patients.create_index([("hospital_name", ASCENDING)])
        # Compound index for hospital-scoped queries (most common access pattern)
        db.patients.create_index(
            [("hospital_name", ASCENDING), ("patient_id", ASCENDING)],
            name="hospital_patient_lookup",
        )
        db.patients.create_index([
            ("patient_id", ASCENDING),
            ("patient_name", ASCENDING),
            ("disease", ASCENDING),
        ], name="text_search_fields")

        db.audit_logs.create_index([("timestamp", DESCENDING)])
        db.audit_logs.create_index([("action", ASCENDING)])

        db.training_logs.create_index([("round", ASCENDING)])

        db.hospitals.create_index([("username", ASCENDING)], unique=True)

        db.trials.create_index([("drugName", ASCENDING)], unique=True)

        logger.info("MongoDB indexes ensured")
    except Exception as e:
        logger.warning(f"Index creation issue (non-fatal): {e}")


# ---------------------------------------------------------------------------
# Seed helpers — migrate existing JSON data to MongoDB (runs once)
# ---------------------------------------------------------------------------

# Default hospital credentials
DEFAULT_HOSPITALS = [
    {
        "username": "SaiPrasad24S",
        "password": "2724",
        "hospital_name": "Sai Prasad Medical Science",
        "email": "admin@saiprasadms.com",
    },
    {
        "username": "Apollo",
        "password": "apollo9",
        "hospital_name": "Apollo Hospitals",
        "email": "admin@apollo.com",
    },
    {
        "username": "KIMS",
        "password": "kims8",
        "hospital_name": "KIMS Hospital",
        "email": "admin@kims.com",
    },
    {
        "username": "Medicover",
        "password": "medicover5",
        "hospital_name": "Medicover Hospital",
        "email": "admin@medicover.com",
    },
    {
        "username": "Citizens",
        "password": "citizens4",
        "hospital_name": "Citizens Hospital",
        "email": "admin@citizens.com",
    },
]

# Default trial definitions
DEFAULT_TRIALS = [
    {"drugName": "Metformin-XL",     "indication": "Diabetes",           "phase": "Phase III", "status": "Active",    "successRate": 72.4},
    {"drugName": "Cardiozen-B",      "indication": "Heart Disease",      "phase": "Phase III", "status": "Active",    "successRate": 65.8},
    {"drugName": "Oncoguard-7",      "indication": "Cancer",             "phase": "Phase II",  "status": "Active",    "successRate": 48.2},
    {"drugName": "Pneumofix-R",      "indication": "Pneumonia",          "phase": "Phase III", "status": "Active",    "successRate": 81.3},
    {"drugName": "Nephrostat-C",     "indication": "Kidney Disease",     "phase": "Phase II",  "status": "Active",    "successRate": 59.7},
    {"drugName": "Hepatocure-D",     "indication": "Liver Disease",      "phase": "Phase III", "status": "Active",    "successRate": 63.1},
    {"drugName": "NeuroShield-X",    "indication": "Stroke",             "phase": "Phase II",  "status": "Active",    "successRate": 55.9},
    {"drugName": "Arthroven-P",      "indication": "Arthritis",          "phase": "Phase III", "status": "Active",    "successRate": 70.2},
    {"drugName": "Pulmoclear-S",     "indication": "Asthma",             "phase": "Phase III", "status": "Completed", "successRate": 76.5},
    {"drugName": "HyperNorm-T",      "indication": "Hypertension",       "phase": "Phase III", "status": "Active",    "successRate": 68.9},
    {"drugName": "ThyroBalance-F",   "indication": "Thyroid Disorder",   "phase": "Phase II",  "status": "Active",    "successRate": 61.4},
    {"drugName": "Bortezomib",       "indication": "Multiple Myeloma",   "phase": "Phase III", "status": "Active",    "successRate": 52.0},
    {"drugName": "Anemiron-G",       "indication": "Anemia",             "phase": "Phase III", "status": "Active",    "successRate": 74.1},
    {"drugName": "DermaHeal-V",      "indication": "Skin Disease",       "phase": "Phase II",  "status": "Active",    "successRate": 66.3},
    {"drugName": "GastroEase-M",     "indication": "Gastrointestinal",   "phase": "Phase III", "status": "Active",    "successRate": 71.0},
]


def seed_hospitals():
    """Insert default hospital credentials if collection is empty."""
    db = get_sync_db()
    if db.hospitals.count_documents({}) == 0:
        for h in DEFAULT_HOSPITALS:
            try:
                db.hospitals.update_one(
                    {"username": h["username"]},
                    {"$set": h},
                    upsert=True,
                )
            except Exception:
                pass
        logger.info(f"Seeded {len(DEFAULT_HOSPITALS)} hospital credentials")
    else:
        logger.info(f"Hospitals collection already has {db.hospitals.count_documents({})} records")


def seed_trials():
    """Insert default trial definitions if collection is empty."""
    db = get_sync_db()
    if db.trials.count_documents({}) == 0:
        for t in DEFAULT_TRIALS:
            try:
                db.trials.update_one(
                    {"drugName": t["drugName"]},
                    {"$set": t},
                    upsert=True,
                )
            except Exception:
                pass
        logger.info(f"Seeded {len(DEFAULT_TRIALS)} trial definitions")
    else:
        logger.info(f"Trials collection already has {db.trials.count_documents({})} records")


def seed_patients_from_json(json_path: str, batch_size: int = 5000):
    """Load patients from medical_data.json into MongoDB if collection is empty."""
    db = get_sync_db()
    existing = db.patients.count_documents({})
    if existing > 0:
        logger.info(f"Patients collection already has {existing} records — skipping JSON seed")
        return existing

    if not os.path.exists(json_path):
        logger.warning(f"JSON file not found: {json_path}")
        return 0

    logger.info(f"Loading patients from {json_path} ...")
    with open(json_path, "r", encoding="utf-8") as f:
        raw = json.load(f)

    patients = []
    if "patients" in raw and isinstance(raw["patients"], list):
        patients = raw["patients"]
    elif "hospitals" in raw:
        for hosp, plist in raw["hospitals"].items():
            patients.extend(plist)

    if not patients:
        logger.warning("No patients found in JSON file")
        return 0

    # Bulk insert in batches
    total_inserted = 0
    for i in range(0, len(patients), batch_size):
        batch = patients[i : i + batch_size]
        # Remove _id if present to avoid conflicts
        for p in batch:
            p.pop("_id", None)
        try:
            result = db.patients.insert_many(batch, ordered=False)
            total_inserted += len(result.inserted_ids)
        except BulkWriteError as bwe:
            total_inserted += bwe.details.get("nInserted", 0)
        except Exception as e:
            err_msg = str(e)
            if "space quota" in err_msg or "AtlasError" in err_msg:
                logger.warning(f"Atlas storage quota reached after {total_inserted} patients — stopping seed")
                break
            raise
        if (i // batch_size) % 10 == 0:
            logger.info(f"  ... inserted {total_inserted}/{len(patients)} patients")

    logger.info(f"Seeded {total_inserted} patients into MongoDB")
    return total_inserted


def seed_audit_logs_from_json(json_path: str):
    """Migrate existing audit_logs.json into MongoDB."""
    db = get_sync_db()
    if db.audit_logs.count_documents({}) > 0:
        logger.info(f"Audit logs collection already has {db.audit_logs.count_documents({})} records — skipping")
        return

    if not os.path.exists(json_path):
        return

    try:
        with open(json_path, "r", encoding="utf-8") as f:
            data = json.load(f)
        logs = data.get("audit_logs", [])
        if logs:
            for log in logs:
                log.pop("_id", None)
            db.audit_logs.insert_many(logs, ordered=False)
            logger.info(f"Migrated {len(logs)} audit logs from JSON to MongoDB")
    except Exception as e:
        logger.warning(f"Failed to migrate audit logs: {e}")


# ---------------------------------------------------------------------------
# Full seed/init (called once at server startup)
# ---------------------------------------------------------------------------
def init_database():
    """Initialize MongoDB: connect, create indexes, seed hospital & trial config.

    Patient data and audit logs are managed exclusively through MongoDB —
    no local JSON files are read or written.
    """
    try:
        # Quick connection test
        client = get_sync_client()
        client.admin.command("ping")
        logger.info(f"Connected to MongoDB: {MONGO_URI[:40]}...")
    except Exception as e:
        logger.error(f"Failed to connect to MongoDB: {e}")
        raise

    ensure_indexes()
    seed_hospitals()
    seed_trials()

    # Report current collection sizes
    db = get_sync_db()
    logger.info(
        f"Collections — patients: {db.patients.estimated_document_count()}, "
        f"audit_logs: {db.audit_logs.estimated_document_count()}, "
        f"training_logs: {db.training_logs.estimated_document_count()}"
    )
    logger.info("Database initialization complete")


# ---------------------------------------------------------------------------
# Async helpers used by FastAPI endpoints
# ---------------------------------------------------------------------------

async def count_patients(filter_query: dict = None) -> int:
    db = get_async_db()
    return await db.patients.count_documents(filter_query or {})


async def count_patients_for_hospital(hospital_name: str) -> int:
    """Count patients belonging to a specific hospital."""
    db = get_async_db()
    return await db.patients.count_documents({"hospital_name": hospital_name})


async def get_patients_paginated(
    page: int = 1,
    page_size: int = 50,
    search: str = None,
    sort_by: str = None,
    sort_dir: str = "asc",
    hospital_name: str = None,
) -> Dict[str, Any]:
    """Return paginated patients with server-side search & sort.

    If *hospital_name* is provided, only patients belonging to that hospital
    are returned.  This ensures each hospital sees only its own records.
    """
    db = get_async_db()

    query = {}
    # Scope to a specific hospital when provided
    if hospital_name:
        query["hospital_name"] = hospital_name

    if search:
        # Text search across key fields
        regex = {"$regex": search, "$options": "i"}
        search_clause = [
            {"patient_id": regex},
            {"patient_name": regex},
            {"disease": regex},
            {"gender": regex},
            {"blood_group": regex},
            {"stage": regex},
            {"phone": regex},
            {"email": regex},
            {"address": regex},
        ]
        if hospital_name:
            # Combine hospital filter with text search
            query = {"$and": [{"hospital_name": hospital_name}, {"$or": search_clause}]}
        else:
            query["$or"] = search_clause

    total = await db.patients.count_documents(query)

    # Sort
    sort_spec = None
    if sort_by:
        direction = DESCENDING if sort_dir == "desc" else ASCENDING
        sort_spec = [(sort_by, direction)]

    # Pagination
    page = max(1, page)
    page_size = min(max(1, page_size), 200)
    skip = (page - 1) * page_size
    total_pages = max(1, -(-total // page_size))

    cursor = db.patients.find(query, {"_id": 0})
    if sort_spec:
        cursor = cursor.sort(sort_spec)
    cursor = cursor.skip(skip).limit(page_size)

    patients = await cursor.to_list(length=page_size)

    # Detect columns from first batch — enforce preferred order
    columns = []
    hidden = {"eligible", "drug_worked", "drug", "hospital_name"}
    # Preferred column order: personal details first, then medical
    PREFERRED_ORDER = [
        "patient_id", "patient_name", "age", "gender", "phone", "email",
        "address", "blood_group", "disease", "stage", "comorbidities",
        "bmi", "diagnosis_date", "admission_date", "emergency_contact",
        "hospital_name",
    ]
    if patients:
        all_keys = set()
        for p in patients[:20]:
            all_keys.update(k for k in p.keys() if k not in hidden)
        # Add columns in preferred order first, then any remaining
        for col in PREFERRED_ORDER:
            if col in all_keys:
                columns.append(col)
                all_keys.discard(col)
        # Append any extra columns not in the preferred list
        columns.extend(sorted(all_keys))

    return {
        "patients": patients,
        "columns": columns,
        "total": total,
        "page": page,
        "page_size": page_size,
        "total_pages": total_pages,
    }


async def get_all_patients_list() -> List[dict]:
    """Return ALL patients as a list (for trial eligibility computation)."""
    db = get_async_db()
    cursor = db.patients.find({}, {"_id": 0})
    return await cursor.to_list(length=None)


# Projection that only fetches fields needed for eligibility checks
_ELIGIBILITY_PROJECTION = {
    "_id": 0, "patient_id": 1, "age": 1, "gender": 1, "blood_group": 1,
    "disease": 1, "stage": 1, "comorbidities": 1, "bmi": 1,
    "diagnosis_date": 1, "hospital_name": 1,
}


async def get_all_patients_for_eligibility() -> List[dict]:
    """Return ALL patients with only the fields needed for eligibility.

    This is much faster than get_all_patients_list() because personal
    fields (name, phone, email, address, etc.) are excluded via projection.
    """
    db = get_async_db()
    cursor = db.patients.find({}, _ELIGIBILITY_PROJECTION)
    return await cursor.to_list(length=None)


async def get_patient_sample(size: int = 2000) -> List[dict]:
    """Return a random sample of patients for estimation.

    Uses MongoDB $sample aggregation stage for efficient random sampling.
    """
    db = get_async_db()
    total = await db.patients.count_documents({})
    if total <= size:
        cursor = db.patients.find({}, _ELIGIBILITY_PROJECTION)
        return await cursor.to_list(length=None)
    pipeline = [
        {"$sample": {"size": size}},
        {"$project": _ELIGIBILITY_PROJECTION},
    ]
    return [doc async for doc in db.patients.aggregate(pipeline)]


async def get_disease_counts() -> Dict[str, int]:
    """Aggregate patient counts by disease."""
    db = get_async_db()
    pipeline = [
        {"$group": {"_id": "$disease", "count": {"$sum": 1}}},
    ]
    result = {}
    async for doc in db.patients.aggregate(pipeline):
        if doc["_id"]:
            result[doc["_id"]] = doc["count"]
    return result


async def get_patients_for_disease(disease: str) -> List[dict]:
    """Return patients with a specific disease."""
    db = get_async_db()
    cursor = db.patients.find({"disease": disease}, {"_id": 0})
    return await cursor.to_list(length=None)


async def insert_patients(patients: List[dict], hospital_name: str = None) -> int:
    """Insert new patient records. If *hospital_name* is given, each record is
    tagged with that hospital so it can be scoped to the uploading account."""
    if not patients:
        return 0
    db = get_async_db()
    for p in patients:
        p.pop("_id", None)
        if hospital_name:
            p["hospital_name"] = hospital_name
    result = await db.patients.insert_many(patients, ordered=False)
    return len(result.inserted_ids)


async def get_patient_stats(hospital_name: str = None) -> Dict[str, Any]:
    """Get fast aggregate stats, optionally scoped to a hospital."""
    db = get_async_db()
    match_stage = {"hospital_name": hospital_name} if hospital_name else {}
    total = await db.patients.count_documents(match_stage)
    pipeline = []
    if match_stage:
        pipeline.append({"$match": match_stage})
    pipeline += [
        {"$group": {"_id": "$disease"}},
        {"$count": "unique_diseases"},
    ]
    disease_count = 0
    async for doc in db.patients.aggregate(pipeline):
        disease_count = doc.get("unique_diseases", 0)

    # Also return global total for federated context
    global_total = await db.patients.count_documents({})
    return {
        "total_patients": total,
        "unique_diseases": disease_count,
        "global_total_patients": global_total,
    }


async def get_hospital_patient_counts() -> Dict[str, int]:
    """Return {hospital_name: patient_count} for all hospitals."""
    db = get_async_db()
    pipeline = [
        {"$group": {"_id": "$hospital_name", "count": {"$sum": 1}}},
    ]
    result = {}
    async for doc in db.patients.aggregate(pipeline):
        if doc["_id"]:
            result[doc["_id"]] = doc["count"]
    return result


# ---------------------------------------------------------------------------
# Audit log helpers
# ---------------------------------------------------------------------------

async def insert_audit_log(entry: dict):
    """Insert a single audit log entry."""
    db = get_async_db()
    entry.pop("_id", None)
    await db.audit_logs.insert_one(entry)


def insert_audit_log_sync(entry: dict):
    """Insert a single audit log entry (synchronous — for blockchain logger)."""
    db = get_sync_db()
    entry_copy = dict(entry)
    entry_copy.pop("_id", None)
    db.audit_logs.insert_one(entry_copy)


async def get_audit_logs(limit: int = 500) -> List[dict]:
    """Return audit logs, newest first."""
    db = get_async_db()
    cursor = db.audit_logs.find({}, {"_id": 0}).sort("timestamp", DESCENDING).limit(limit)
    return await cursor.to_list(length=limit)


async def get_audit_log_count() -> int:
    db = get_async_db()
    return await db.audit_logs.count_documents({})


# ---------------------------------------------------------------------------
# Training log helpers
# ---------------------------------------------------------------------------

async def insert_training_log(entry: dict):
    """Insert a training round log."""
    db = get_async_db()
    entry.pop("_id", None)
    await db.training_logs.insert_one(entry)


def insert_training_log_sync(entry: dict):
    """Insert a training round log (synchronous)."""
    db = get_sync_db()
    entry_copy = dict(entry)
    entry_copy.pop("_id", None)
    db.training_logs.insert_one(entry_copy)


async def get_training_logs() -> List[dict]:
    """Return all training logs ordered by round."""
    db = get_async_db()
    cursor = db.training_logs.find({}, {"_id": 0}).sort("round", ASCENDING)
    return await cursor.to_list(length=None)


async def clear_training_logs():
    """Clear all training logs."""
    db = get_async_db()
    await db.training_logs.delete_many({})


# ---------------------------------------------------------------------------
# Hospital/auth helpers
# ---------------------------------------------------------------------------

async def get_hospitals() -> List[dict]:
    """Return all hospital credentials."""
    db = get_async_db()
    cursor = db.hospitals.find({}, {"_id": 0})
    return await cursor.to_list(length=None)


async def authenticate_hospital(username: str, password: str) -> Optional[dict]:
    """Authenticate a hospital user. Returns user dict or None."""
    db = get_async_db()
    hospital = await db.hospitals.find_one(
        {"username": username, "password": password},
        {"_id": 0},
    )
    return hospital


# ---------------------------------------------------------------------------
# Trial helpers
# ---------------------------------------------------------------------------

async def get_trials_from_db() -> List[dict]:
    """Return all trial definitions."""
    db = get_async_db()
    cursor = db.trials.find({}, {"_id": 0})
    return await cursor.to_list(length=None)


async def create_trial(trial: dict) -> dict:
    """Insert a new trial definition into MongoDB.

    Returns the inserted trial (without _id).
    Raises ValueError if drugName already exists.
    """
    db = get_async_db()
    existing = await db.trials.find_one({"drugName": trial["drugName"]})
    if existing:
        raise ValueError(f"Trial with drug name '{trial['drugName']}' already exists")
    await db.trials.insert_one(trial)
    trial.pop("_id", None)
    return trial


================================================================================
--- FILE: .\data_utils.py ---
================================================================================
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.utils.class_weight import compute_class_weight

# Gender and stage encoding maps (must match preprocessing.py)
_GENDER_MAP = {"Male": 0, "Female": 1}
_STAGE_MAP = {"I": 1, "II": 2, "III": 3, "IV": 4}


def _load_patients_from_mongo() -> pd.DataFrame:
    """Load patient records from MongoDB and build a training DataFrame."""
    import os, certifi
    from pymongo import MongoClient
    from dotenv import load_dotenv

    load_dotenv()
    client = MongoClient(os.getenv("MONGO_URI"), tlsCAFile=certifi.where())
    db = client[os.getenv("MONGO_DB_NAME")]

    patients = list(db.patients.find({}, {
        "_id": 0, "age": 1, "gender": 1, "comorbidities": 1,
        "stage": 1, "bmi": 1, "eligible": 1,
    }))

    if not patients:
        raise ValueError("No patient records found in MongoDB")

    df = pd.DataFrame(patients)

    # Encode columns for training
    df["gender_enc"] = df["gender"].map(_GENDER_MAP).fillna(0).astype(int)
    df["num_comorbidities"] = df["comorbidities"].apply(
        lambda x: len(x) if isinstance(x, list) else 0
    )
    df["stage_enc"] = df["stage"].map(_STAGE_MAP).fillna(2).astype(int)
    df["bmi"] = df["bmi"].astype(float)
    df["age"] = df["age"].astype(float)

    # Default eligible to 0 if missing, then assign synthetic labels
    # for training (real eligibility is computed per-trial at inference time)
    if "eligible" not in df.columns or df["eligible"].isna().all():
        # Generate synthetic training labels based on patient features
        # Patients with lower stage, younger age, and fewer comorbidities
        # are more likely to be eligible
        np.random.seed(42)
        score = (
            (df["age"] < 65).astype(float) * 0.3
            + (df["stage_enc"] <= 2).astype(float) * 0.3
            + (df["num_comorbidities"] <= 2).astype(float) * 0.2
            + (df["bmi"].between(18.5, 30)).astype(float) * 0.2
        )
        noise = np.random.uniform(0, 0.3, len(df))
        df["eligible"] = ((score + noise) > 0.5).astype(int)
    else:
        df["eligible"] = df["eligible"].fillna(0).astype(int)

    return df


def load_and_preprocess_data():
    """
    Loads patient data from MongoDB and preprocesses it for training.

    Returns:
        Tuple of (X_train, X_test, y_train, y_test, class_weights)
    """
    df = _load_patients_from_mongo()

    X = df[["age", "gender_enc", "num_comorbidities", "stage_enc", "bmi"]]
    y = df["eligible"]

    scaler = StandardScaler()
    X = scaler.fit_transform(X)

    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, stratify=y, random_state=42
    )

    # Compute class weights (handle single-class edge case)
    unique_classes = np.unique(y_train)
    if len(unique_classes) < 2:
        class_weight_dict = {0: 1.0, 1: 1.0}
    else:
        class_weights = compute_class_weight('balanced', classes=unique_classes, y=y_train)
        class_weight_dict = {int(c): float(w) for c, w in zip(unique_classes, class_weights)}

    return X_train, X_test, y_train, y_test, class_weight_dict

================================================================================
--- FILE: .\model.py ---
================================================================================
import tensorflow as tf

def create_model(input_dim: int) -> tf.keras.Model:
    """
    Creates a neural network model for drug trial eligibility prediction.

    Args:
        input_dim: Number of input features

    Returns:
        Compiled Keras model
    """
    model = tf.keras.Sequential([
        tf.keras.layers.Dense(32, activation="relu", input_shape=(input_dim,)),
        tf.keras.layers.Dropout(0.2),
        tf.keras.layers.Dense(16, activation="relu"),
        tf.keras.layers.Dropout(0.2),
        tf.keras.layers.Dense(8, activation="relu"),
        tf.keras.layers.Dense(1, activation="sigmoid")
    ])

    model.compile(
        optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
        loss="binary_crossentropy",
        metrics=["accuracy"]
    )

    return model

================================================================================
--- FILE: .\preprocessing.py ---
================================================================================
"""
Preprocessing Pipeline for Federated Drug Trial Screener
=========================================================
Converts uploaded files (CSV, JSON, PDF) into a standard patient CSV format,
then generates the federated JSON structure (grouped by hospital) for the
application to consume.

Standard CSV columns:
    patient_id, age, gender, blood_group, disease, stage, comorbidities,
    bmi, diagnosis_date, drug, eligible, drug_worked, hospital

The pipeline:
    1. Detect file type → parse raw content into a pandas DataFrame.
    2. Normalise / map columns to the standard schema.
    3. Fill missing values with sensible defaults.
    4. Export a clean CSV (for audit / federated training).
    5. Convert to the JSON structure expected by the app
       ({"hospitals": {"HospitalName": [patient_dicts]}}).
"""

import os
import io
import re
import json
import uuid
import hashlib
from datetime import datetime
from typing import Tuple, Dict, Any, Optional, List

import pandas as pd
import numpy as np

# Optional PDF support
try:
    import PyPDF2
    PYPDF2_AVAILABLE = True
except ImportError:
    PYPDF2_AVAILABLE = False

# ---------------------------------------------------------------------------
# Column mapping: we try to recognise many common column name variants
# ---------------------------------------------------------------------------
COLUMN_ALIASES = {
    "patient_id": ["patient_id", "patientid", "id", "pid", "patient", "subject_id", "hadm_id", "record_id"],
    "patient_name": ["patient_name", "patientname", "name", "full_name", "fullname", "first_name"],
    "phone": ["phone", "phone_number", "mobile", "contact_number", "telephone", "cell"],
    "email": ["email", "email_address", "e_mail", "emailid"],
    "address": ["address", "residential_address", "home_address", "street_address", "location"],
    "emergency_contact": ["emergency_contact", "emergency_phone", "next_of_kin", "guardian_contact", "kin_phone"],
    "admission_date": ["admission_date", "admit_date", "admittime", "date_of_admission", "admitted_on"],
    "age": ["age", "patient_age", "age_years", "years"],
    "gender": ["gender", "sex", "gender_enc", "male", "female", "m/f"],
    "blood_group": ["blood_group", "bloodgroup", "blood_type", "bloodtype", "blood"],
    "disease": ["disease", "diagnosis", "condition", "indication", "primary_diagnosis", "icd_title"],
    "stage": ["stage", "stage_enc", "disease_stage", "cancer_stage", "severity"],
    "comorbidities": ["comorbidities", "comorbidity", "comorbid", "other_conditions", "secondary_diagnosis"],
    "bmi": ["bmi", "body_mass_index", "bodymassindex"],
    "diagnosis_date": ["diagnosis_date", "date", "dx_date"],
    "drug": ["drug", "medication", "treatment", "drug_name", "medicine", "therapy", "prescription"],
    "eligible": ["eligible", "eligibility", "is_eligible"],
    "drug_worked": ["drug_worked", "drugworked", "outcome", "response", "effective", "success"],
    "hospital": ["hospital", "hospital_name", "facility", "site", "centre", "center", "source"],
}

# Standard columns in output order
STANDARD_COLUMNS = [
    "patient_id", "patient_name", "phone", "email", "address",
    "emergency_contact", "admission_date",
    "age", "gender", "blood_group", "disease", "stage",
    "comorbidities", "bmi", "diagnosis_date", "drug", "eligible",
    "drug_worked", "hospital"
]

GENDER_MAP = {
    0: "Male", 1: "Female", "0": "Male", "1": "Female",
    "m": "Male", "f": "Female", "male": "Male", "female": "Female",
    "M": "Male", "F": "Female",
}

STAGE_MAP = {
    1: "I", 2: "II", 3: "III", 4: "IV",
    "1": "I", "2": "II", "3": "III", "4": "IV",
    "i": "I", "ii": "II", "iii": "III", "iv": "IV",
    "stage i": "I", "stage ii": "II", "stage iii": "III", "stage iv": "IV",
}

BLOOD_GROUPS = ["A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-"]


# ========================== PARSERS ======================================

def parse_csv(content: bytes, filename: str = "") -> pd.DataFrame:
    """Parse CSV bytes into a DataFrame."""
    try:
        df = pd.read_csv(io.BytesIO(content))
    except Exception:
        # Try different encodings / delimiters
        for enc in ("utf-8", "latin-1", "cp1252"):
            for sep in (",", ";", "\t", "|"):
                try:
                    df = pd.read_csv(io.BytesIO(content), encoding=enc, sep=sep)
                    if len(df.columns) > 1:
                        return df
                except Exception:
                    continue
        raise ValueError("Could not parse CSV file. Check the delimiter and encoding.")
    return df


def parse_json_file(content: bytes) -> pd.DataFrame:
    """Parse a JSON file into a DataFrame.
    Handles both:
      - {"hospitals": {"Name": [records]}}  (our app format)
      - [records]                           (flat list)
      - {"patients": [records]}
    """
    data = json.loads(content)

    if isinstance(data, list):
        return pd.DataFrame(data)

    if "hospitals" in data:
        rows = []
        for hosp, patients in data["hospitals"].items():
            for p in patients:
                p.setdefault("hospital", hosp)
                rows.append(p)
        return pd.DataFrame(rows)

    if "patients" in data:
        return pd.DataFrame(data["patients"])

    # Try to treat the whole object as a single record
    if isinstance(data, dict):
        return pd.DataFrame([data])

    raise ValueError("Unrecognised JSON structure.")


def parse_pdf(content: bytes) -> pd.DataFrame:
    """Extract tabular patient data from a PDF.
    Uses PyPDF2 to extract text, then tries to parse CSV-like lines.
    """
    if not PYPDF2_AVAILABLE:
        raise ValueError("PDF support requires PyPDF2. Install it with: pip install PyPDF2")

    reader = PyPDF2.PdfReader(io.BytesIO(content))
    text_lines = []
    for page in reader.pages:
        page_text = page.extract_text() or ""
        text_lines.extend(page_text.splitlines())

    if not text_lines:
        raise ValueError("Could not extract any text from the PDF.")

    # Try to detect a header line (contains multiple known column names)
    header_idx = None
    for i, line in enumerate(text_lines):
        lower = line.lower()
        matches = sum(1 for alias_list in COLUMN_ALIASES.values()
                      for alias in alias_list if alias in lower)
        if matches >= 3:
            header_idx = i
            break

    if header_idx is not None:
        # Parse as delimiter-separated (try comma, tab, multiple-spaces)
        header_line = text_lines[header_idx]
        for sep in [",", "\t", "  "]:
            cols = [c.strip() for c in header_line.split(sep) if c.strip()]
            if len(cols) >= 3:
                rows = []
                for line in text_lines[header_idx + 1:]:
                    vals = [v.strip() for v in line.split(sep) if v.strip()]
                    if len(vals) == len(cols):
                        rows.append(vals)
                if rows:
                    return pd.DataFrame(rows, columns=cols)

    # Fallback: try regex for structured patient-like rows
    # Look for lines like: "SP001, 45, Male, O+, ..."
    pattern = re.compile(
        r'([A-Z]{1,5}\d{2,6})\s*[,|]\s*(\d{1,3})\s*[,|]\s*(Male|Female|M|F)\s*[,|]',
        re.IGNORECASE
    )
    rows = []
    for line in text_lines:
        m = pattern.search(line)
        if m:
            parts = re.split(r'[,|\t]+', line)
            rows.append([p.strip() for p in parts])

    if rows:
        # Try to guess columns
        max_cols = max(len(r) for r in rows)
        # Pad short rows
        rows = [r + [""] * (max_cols - len(r)) for r in rows]
        col_names = STANDARD_COLUMNS[:max_cols] if max_cols <= len(STANDARD_COLUMNS) else [f"col_{i}" for i in range(max_cols)]
        return pd.DataFrame(rows, columns=col_names)

    raise ValueError(
        "Could not extract structured patient data from PDF. "
        "Ensure the PDF contains tabular data with headers."
    )


# ========================== NORMALISATION ================================

def _resolve_columns(df: pd.DataFrame) -> Dict[str, str]:
    """Map actual DataFrame column names → standard names."""
    mapping = {}
    used = set()
    df_cols_lower = {c: c.lower().strip().replace(" ", "_") for c in df.columns}

    for std_name, aliases in COLUMN_ALIASES.items():
        for actual_col, lower_col in df_cols_lower.items():
            if actual_col in used:
                continue
            if lower_col in aliases:
                mapping[actual_col] = std_name
                used.add(actual_col)
                break
    return mapping


def _generate_patient_id(row_idx: int, hospital: str = "") -> str:
    seed = f"{hospital}_{row_idx}_{uuid.uuid4().hex[:6]}"
    return "P" + hashlib.md5(seed.encode()).hexdigest()[:7].upper()


def normalise(df: pd.DataFrame, default_hospital: str = "Unknown Hospital") -> pd.DataFrame:
    """Normalise a raw DataFrame into the standard patient schema."""

    # 1. Resolve column names
    col_map = _resolve_columns(df)
    df = df.rename(columns=col_map)

    # 2. Ensure every standard column exists
    for col in STANDARD_COLUMNS:
        if col not in df.columns:
            df[col] = None

    # 3. Keep only standard columns (+ any extras silently dropped)
    df = df[STANDARD_COLUMNS].copy()

    # 4. Type conversions and cleaning
    # Age
    df["age"] = pd.to_numeric(df["age"], errors="coerce")
    df["age"] = df["age"].fillna(df["age"].median() if df["age"].notna().any() else 50)
    df["age"] = df["age"].clip(0, 120).round(0).astype(int)

    # Gender
    df["gender"] = df["gender"].apply(
        lambda x: GENDER_MAP.get(str(x).strip().lower(), GENDER_MAP.get(x, str(x) if pd.notna(x) else "Unknown"))
    )

    # Blood group
    df["blood_group"] = df["blood_group"].apply(
        lambda x: x if (pd.notna(x) and str(x).strip() in BLOOD_GROUPS) else
        np.random.choice(BLOOD_GROUPS) if pd.isna(x) else str(x).strip()
    )

    # Disease
    df["disease"] = df["disease"].fillna("Unknown Disease").astype(str)

    # Stage
    df["stage"] = df["stage"].apply(
        lambda x: STAGE_MAP.get(str(x).strip().lower(), str(x).strip() if pd.notna(x) else
        np.random.choice(["I", "II", "III", "IV"]))
    )

    # Comorbidities (convert from string if needed)
    def _parse_comorbidities(val):
        if isinstance(val, list):
            return val
        if pd.isna(val) or val is None or str(val).strip() in ("", "None", "nan", "[]"):
            return []
        s = str(val).strip()
        if s.startswith("["):
            try:
                return json.loads(s.replace("'", '"'))
            except Exception:
                pass
        return [c.strip() for c in s.split(",") if c.strip()]

    df["comorbidities"] = df["comorbidities"].apply(_parse_comorbidities)

    # If comorbidities came as a count (numeric), expand to placeholder list
    if df["comorbidities"].apply(lambda x: isinstance(x, (int, float))).any():
        df["comorbidities"] = df["comorbidities"].apply(
            lambda x: [f"Condition_{i+1}" for i in range(int(x))] if isinstance(x, (int, float)) and not np.isnan(x) else x
        )

    # BMI
    df["bmi"] = pd.to_numeric(df["bmi"], errors="coerce")
    df["bmi"] = df["bmi"].fillna(df["bmi"].median() if df["bmi"].notna().any() else 25.0).round(1)

    # Diagnosis date
    df["diagnosis_date"] = df["diagnosis_date"].fillna(datetime.now().strftime("%Y-%m-%d"))

    # Drug
    df["drug"] = df["drug"].fillna("Unknown Drug").astype(str)

    # Eligible / drug_worked (binary)
    for col in ("eligible", "drug_worked"):
        df[col] = pd.to_numeric(df[col], errors="coerce").fillna(0).astype(int).clip(0, 1)

    # Hospital
    df["hospital"] = df["hospital"].fillna(default_hospital).astype(str)

    # Patient ID — generate if missing
    mask = df["patient_id"].isna() | (df["patient_id"].astype(str).str.strip() == "")
    if mask.any():
        df.loc[mask, "patient_id"] = [
            _generate_patient_id(i, str(df.loc[i, "hospital"]))
            for i in df.index[mask]
        ]

    return df


# ========================== PIPELINE =====================================

def preprocess_upload(
    content: bytes,
    filename: str,
    default_hospital: str = "Unknown Hospital"
) -> Tuple[pd.DataFrame, Dict[str, Any]]:
    """
    Full preprocessing pipeline.

    Args:
        content: Raw bytes of the uploaded file.
        filename: Original filename (used to detect type).
        default_hospital: Hospital name to assign when not present in data.

    Returns:
        (normalised_df, json_structure)
        - normalised_df: clean pandas DataFrame with standard columns
        - json_structure: {"hospitals": {"Name": [patient_dicts]}} ready to merge
    """
    ext = os.path.splitext(filename)[1].lower()

    if ext == ".csv":
        raw_df = parse_csv(content, filename)
    elif ext == ".json":
        raw_df = parse_json_file(content)
    elif ext == ".pdf":
        raw_df = parse_pdf(content)
    else:
        raise ValueError(f"Unsupported file type: {ext}. Use CSV, JSON, or PDF.")

    if raw_df.empty:
        raise ValueError("The uploaded file contains no data rows.")

    # Normalise
    df = normalise(raw_df, default_hospital=default_hospital)

    # Build JSON structure grouped by hospital
    json_structure: Dict[str, Any] = {"hospitals": {}}
    for hospital, group in df.groupby("hospital"):
        records = group.to_dict(orient="records")
        # Ensure comorbidities stays as list (json-safe)
        for r in records:
            if not isinstance(r.get("comorbidities"), list):
                r["comorbidities"] = []
        json_structure["hospitals"][hospital] = records

    return df, json_structure


def save_standard_csv(df: pd.DataFrame, output_dir: str, filename_prefix: str = "patients") -> str:
    """Save the normalised DataFrame as a standard CSV for audit / training."""
    os.makedirs(output_dir, exist_ok=True)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    csv_path = os.path.join(output_dir, f"{filename_prefix}_{timestamp}.csv")
    df.to_csv(csv_path, index=False)
    return csv_path


def generate_federated_training_csv(df: pd.DataFrame, output_path: str) -> str:
    """
    Convert the standard patient DataFrame into the numeric format expected
    by the federated training pipeline (mimic_adapted.csv compatible).

    Columns: age, gender_enc, num_comorbidities, stage_enc, bmi, eligible
    """
    train_df = pd.DataFrame()
    train_df["age"] = df["age"].astype(float)
    train_df["gender_enc"] = df["gender"].map({"Male": 0, "Female": 1}).fillna(0).astype(int)
    train_df["num_comorbidities"] = df["comorbidities"].apply(lambda x: len(x) if isinstance(x, list) else 0)

    stage_enc_map = {"I": 1, "II": 2, "III": 3, "IV": 4}
    train_df["stage_enc"] = df["stage"].map(stage_enc_map).fillna(2).astype(int)
    train_df["bmi"] = df["bmi"].astype(float)
    train_df["eligible"] = df["eligible"].astype(int)

    train_df.to_csv(output_path, index=False)
    return output_path


================================================================================
--- FILE: .\README.md ---
================================================================================
# Federated Drug Trial Eligibility Screener

A privacy-preserving federated learning system for drug trial eligibility prediction using medical data, with blockchain-based audit logging.

## Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   FL Clients    │    │   FL Server     │    │   Blockchain    │
│   (Hospitals)   │◄──►│   (Coordinator) │◄──►│   (Audit Log)   │
│                 │    │                 │    │                 │
│ - Local Training│    │ - FedAvg        │    │ - Metadata Only │
│ - Privacy       │    │ - Aggregation   │    │ - Immutable     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              ▲
                              │
                       ┌─────────────────┐
                       │   FastAPI       │
                       │   REST API      │
                       │                 │
                       │ - Start FL      │
                       │ - Get Logs      │
                       │ - Get Metrics   │
                       └─────────────────┘
```

## Features

- **Federated Learning**: Privacy-preserving distributed training using Flower
- **Neural Network**: TensorFlow/Keras model for eligibility prediction
- **Blockchain Audit**: Ethereum-based immutable logging of training metadata
- **REST API**: FastAPI endpoints for system control and monitoring
- **Modular Design**: Separated concerns for maintainability

## Setup

### Prerequisites

- Python 3.8+
- Node.js & npm (for Ganache)
- Git

### Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd federated_screener
```

2. Install Python dependencies:
```bash
pip install -r requirements.txt
```

3. Set up blockchain (local Ganache):
```bash
npm install -g ganache
ganache
```

4. Configure environment:
```bash
cp .env.example .env
# Edit .env with your blockchain settings
```

### Smart Contract Deployment

#### Prerequisites

- Node.js & npm
- Truffle or Hardhat
- Ganache (for local testing)

#### Local Deployment (Ganache)

1. **Install dependencies**:
```bash
npm install -g truffle
npm install @openzeppelin/contracts
```

2. **Start Ganache**:
```bash
ganache
```

3. **Create Truffle project**:
```bash
mkdir blockchain-deployment
cd blockchain-deployment
truffle init
```

4. **Copy contract**:
```bash
cp ../blockchain/FederatedTrainingLogger.sol contracts/
```

5. **Install OpenZeppelin**:
```bash
npm install @openzeppelin/contracts
```

6. **Update truffle-config.js**:
```javascript
module.exports = {
  networks: {
    development: {
      host: "127.0.0.1",
      port: 8545,
      network_id: "*",
    },
  },
  compilers: {
    solc: {
      version: "^0.8.19",
    },
  },
};
```

7. **Create migration file** (`migrations/2_deploy_contracts.js`):
```javascript
const FederatedTrainingLogger = artifacts.require("FederatedTrainingLogger");

module.exports = function(deployer) {
  deployer.deploy(FederatedTrainingLogger);
};
```

8. **Deploy contract**:
```bash
truffle migrate --network development
```

9. **Update .env**:
```bash
CONTRACT_ADDRESS=0xYourDeployedContractAddress
PRIVATE_KEY=0xYourPrivateKeyFromGanache
```

#### Sepolia Testnet Deployment

1. **Install Hardhat**:
```bash
npm install --save-dev hardhat
npx hardhat init
```

2. **Configure Hardhat** (`hardhat.config.js`):
```javascript
require("@nomiclabs/hardhat-ethers");
require("@nomiclabs/hardhat-waffle");

module.exports = {
  solidity: "0.8.19",
  networks: {
    sepolia: {
      url: `https://sepolia.infura.io/v3/${process.env.INFURA_PROJECT_ID}`,
      accounts: [process.env.PRIVATE_KEY]
    }
  }
};
```

3. **Copy contract to contracts folder**:
```bash
cp ../blockchain/FederatedTrainingLogger.sol contracts/
```

4. **Create deployment script** (`scripts/deploy.js`):
```javascript
const { ethers } = require("hardhat");

async function main() {
  const FederatedTrainingLogger = await ethers.getContractFactory("FederatedTrainingLogger");
  const logger = await FederatedTrainingLogger.deploy();

  await logger.deployed();

  console.log("FederatedTrainingLogger deployed to:", logger.address);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

5. **Deploy to Sepolia**:
```bash
npx hardhat run scripts/deploy.js --network sepolia
```

6. **Update .env**:
```bash
BLOCKCHAIN_LOCAL=false
INFURA_PROJECT_ID=your_infura_project_id
CONTRACT_ADDRESS=0xYourSepoliaContractAddress
PRIVATE_KEY=0xYourSepoliaPrivateKey
```

#### Contract Features

- **Access Control**: Only contract owner can add training logs
- **Gas Efficient**: Batch reading functions and optimized storage
- **Event Logging**: Emits events for off-chain monitoring
- **Validation**: Input validation for data integrity
- **Public Read Access**: Anyone can read training logs for transparency

#### Security Notes

- Only the contract owner can add training logs
- All data is publicly readable for transparency
- No patient data is stored - only training metadata
- Events are emitted for off-chain monitoring

## Usage

### Start the API Server

```bash
python api/main.py
```

### API Endpoints

#### Start Federated Learning
```bash
curl -X POST "http://localhost:8000/start-fl" \
     -H "Content-Type: application/json" \
     -d '{"num_rounds": 10}'
```

#### Get Training Logs
```bash
curl "http://localhost:8000/training-logs"
```

#### Get Model Metrics
```bash
curl "http://localhost:8000/model-metrics"
```

#### Health Check
```bash
curl "http://localhost:8000/health"
```

## Configuration

### Environment Variables

- `BLOCKCHAIN_LOCAL`: Use local Ganache (true) or Sepolia testnet (false)
- `INFURA_PROJECT_ID`: Infura project ID for testnet
- `PRIVATE_KEY`: Ethereum private key for transaction signing
- `CONTRACT_ADDRESS`: Deployed smart contract address

### Switching to Testnet

1. Set `BLOCKCHAIN_LOCAL=false` in `.env`
2. Add your `INFURA_PROJECT_ID`
3. Fund your account with Sepolia ETH
4. Deploy contract to Sepolia and update `CONTRACT_ADDRESS`

## Security Considerations

- **Private Keys**: Never commit private keys to version control
- **Patient Data**: No sensitive medical data is stored on blockchain
- **Access Control**: Implement authentication for API endpoints in production
- **Rate Limiting**: Add rate limiting to prevent abuse

## Development

### Project Structure

```
federated_screener/
├── api/                    # FastAPI REST endpoints
├── blockchain/            # Ethereum interaction
├── clients/               # FL client implementations
├── fl_server/            # FL server configuration
├── model.py              # Neural network model
├── data_utils.py         # Data preprocessing
├── requirements.txt      # Python dependencies
└── .env.example          # Environment template
```

### Running Tests

```bash
# Unit tests
python -m pytest

# Integration tests
python -m pytest tests/integration/
```

## License

MIT License - see LICENSE file for details.

================================================================================
--- FILE: .\requirements.txt ---
================================================================================
flwr[simulation]
tensorflow
web3
fastapi
uvicorn
python-dotenv
pandas
scikit-learn
eth-account
PyPDF2
motor
pymongo[srv]
python-multipart

================================================================================
--- FILE: .\run_backend.py ---
================================================================================
#!/usr/bin/env python3
"""
Simple script to run the backend API
"""

import sys
import os

# Add current directory to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from api.main import app
import uvicorn

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8002)

================================================================================
--- FILE: .\api\main.py ---
================================================================================
from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel
import threading
import time
from typing import List, Dict, Any, Optional
import sys
import os
import json
from datetime import datetime

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# ---------------------------------------------------------------------------
# MongoDB setup
# ---------------------------------------------------------------------------
import database as db

# Initialize database (sync — runs during import/startup)
try:
    db.init_database()
    print("[DATABASE] MongoDB initialized successfully")
except Exception as e:
    print(f"[DATABASE] MongoDB initialization failed: {e}")
    import traceback
    traceback.print_exc()



# ---------------------------------------------------------------------------
# Blockchain logger
# ---------------------------------------------------------------------------
try:
    from blockchain.logger import get_safe_blockchain_logger, MockBlockchainLogger
    blockchain_logger = get_safe_blockchain_logger(strict=False)
    if getattr(blockchain_logger, "is_mock", False) or isinstance(blockchain_logger, MockBlockchainLogger):
        print("[BLOCKCHAIN] Mode: MOCK (no on-chain connectivity)")
    else:
        print("[BLOCKCHAIN] Mode: REAL (connected to blockchain)")
except Exception as e:
    print(f"[BLOCKCHAIN] Logger import/init failed: {e}")
    from blockchain.logger import MockBlockchainLogger
    blockchain_logger = MockBlockchainLogger()
    print("[BLOCKCHAIN] Mode: MOCK (fallback due to init error)")

# ---------------------------------------------------------------------------
# FastAPI app
# ---------------------------------------------------------------------------
app = FastAPI(title="Federated Drug Trial Eligibility Screener API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ---------------------------------------------------------------------------
# Root endpoint
# ---------------------------------------------------------------------------
@app.get("/")
async def root():
    """Root endpoint — basic API info."""
    return {
        "name": "Federated Drug Trial Eligibility Screener API",
        "version": "1.0.0",
        "docs": "/docs",
        "health": "/health",
    }

# ---------------------------------------------------------------------------
# Global in-memory state (training only — ephemeral)
# ---------------------------------------------------------------------------
training_logs: list = []
is_training: bool = False

# ---------------------------------------------------------------------------
# Server-side result caches (avoids reloading all patients on every request)
# ---------------------------------------------------------------------------
_trials_cache: Dict[str, Any] = {"data": None, "ts": 0}
_TRIALS_CACHE_TTL = 15  # seconds
_eligibility_cache: Dict[str, Any] = {}  # key = drug_name -> {data, ts}
_ELIGIBILITY_CACHE_TTL = 10  # seconds

# ---------------------------------------------------------------------------
# Blockchain audit-log throttle  (prevents spamming on repeated page views)
# ---------------------------------------------------------------------------
_audit_last_logged: Dict[str, float] = {}   # action -> last epoch
_AUDIT_COOLDOWN = 10  # seconds between duplicate action logs

def _should_log_action(action: str, cooldown: float = _AUDIT_COOLDOWN) -> bool:
    """Return True if enough time has passed since the last log of this action."""
    now = time.time()
    last = _audit_last_logged.get(action, 0)
    if now - last >= cooldown:
        _audit_last_logged[action] = now
        return True
    return False

def _log_audit(action: str, details: str = "", actor: str = "Unknown Hospital",
               record_count: int = 0, metadata: dict = None,
               cooldown: float = _AUDIT_COOLDOWN) -> None:
    """Convenience: throttle + fire-and-forget blockchain audit log."""
    if not blockchain_logger or not hasattr(blockchain_logger, 'log_event'):
        return
    if not _should_log_action(action, cooldown):
        return
    try:
        blockchain_logger.log_event(
            action=action, details=details, actor=actor,
            record_count=record_count, metadata=metadata,
        )
    except Exception:
        pass

# ---------------------------------------------------------------------------
# Startup event
# ---------------------------------------------------------------------------
@app.on_event("startup")
async def log_startup_event():
    """Log startup to blockchain audit trail and persist in MongoDB."""
    try:
        stats = await db.get_patient_stats()
        patients_count = stats.get("total_patients", 0)
    except Exception:
        patients_count = 0

    _log_audit(
        action="SYSTEM_STARTUP",
        details=f"FDTES API server started with {patients_count} patients loaded",
        actor="Server",
        record_count=patients_count,
        cooldown=0,  # always log startup
    )

    # Also load training logs from MongoDB into memory
    global training_logs
    try:
        training_logs = await db.get_training_logs()
    except Exception:
        training_logs = []

# ---------------------------------------------------------------------------
# Pydantic models
# ---------------------------------------------------------------------------
class TrainingRequest(BaseModel):
    num_rounds: int = 10

class LoginRequest(BaseModel):
    username: str
    password: str

# ---------------------------------------------------------------------------
# Auth endpoint (replaces hardcoded frontend credentials)
# ---------------------------------------------------------------------------
@app.post("/auth/login")
async def login(request: LoginRequest):
    """Authenticate a hospital user against MongoDB."""
    hospital = await db.authenticate_hospital(request.username, request.password)
    if not hospital:
        _log_audit(
            action="LOGIN_FAILED",
            details=f"Failed login attempt for user '{request.username}'",
            actor=request.username,
            cooldown=2,
        )
        raise HTTPException(status_code=401, detail="Invalid username or password")

    _log_audit(
        action="USER_LOGIN",
        details=f"User '{hospital['username']}' logged in from {hospital['hospital_name']}",
        actor=hospital["hospital_name"],
        cooldown=0,  # always log logins
    )

    return {
        "user": {
            "username": hospital["username"],
            "hospital_name": hospital["hospital_name"],
            "email": hospital.get("email", ""),
            "role": "admin",
        }
    }

# ---------------------------------------------------------------------------
# Training endpoints
# ---------------------------------------------------------------------------
@app.get("/training-logs")
async def get_training_logs_endpoint():
    """Get training logs from MongoDB (falls back to in-memory)."""
    try:
        logs = await db.get_training_logs()
        if logs:
            # Normalize field names for frontend compatibility
            normalized = []
            for log in logs:
                normalized.append({
                    "round": log.get("round", log.get("round_number", 0)),
                    "accuracy": log.get("accuracy", 0),
                    "loss": log.get("loss", 0),
                    "timestamp": str(log.get("timestamp", "")),
                    "model_hash": log.get("model_hash", ""),
                })
            return normalized
    except Exception as e:
        print(f"[TRAINING] Error getting logs from MongoDB: {e}")
    return training_logs

# ---------------------------------------------------------------------------
# Frontend activity logging — lightweight endpoint for UI-driven events
# ---------------------------------------------------------------------------
class ActivityLog(BaseModel):
    action: str
    details: str = ""
    actor: str = "Unknown Hospital"
    record_count: int = 0

@app.post("/log-activity")
async def log_activity(entry: ActivityLog):
    """Log a frontend-initiated activity to the blockchain audit trail."""
    _log_audit(
        action=entry.action,
        details=entry.details,
        actor=entry.actor,
        record_count=entry.record_count,
        cooldown=5,  # 5s throttle for frontend events
    )
    return {"ok": True}

@app.get("/health")
async def health_check():
    mongo_connected = False
    try:
        await db.get_async_db().command("ping")
        mongo_connected = True
    except Exception:
        pass

    blockchain_connected = False
    try:
        if blockchain_logger and hasattr(blockchain_logger, 'w3') and blockchain_logger.w3:
            blockchain_connected = blockchain_logger.w3.is_connected()
    except Exception:
        pass

    return {
        "status": "healthy",
        "blockchain_connected": blockchain_connected,
        "mongodb_connected": mongo_connected,
        "training_active": is_training
    }

# ---------------------------------------------------------------------------
# Blockchain audit logs — served from MongoDB (with response caching)
# ---------------------------------------------------------------------------
_blockchain_logs_cache: Dict[str, Any] = {"data": None, "ts": 0}
_BLOCKCHAIN_CACHE_TTL = 2  # seconds — avoids hitting MongoDB on every poll

@app.get("/blockchain-logs")
async def get_blockchain_logs():
    """Return audit trail — merge MongoDB and in-memory mock logger."""
    now = time.time()
    if _blockchain_logs_cache["data"] and (now - _blockchain_logs_cache["ts"]) < _BLOCKCHAIN_CACHE_TTL:
        return JSONResponse(
            content=_blockchain_logs_cache["data"],
            headers={"Cache-Control": "no-cache, no-store, must-revalidate"},
        )

    all_logs = []

    # 1) Try MongoDB
    try:
        mongo_logs = await db.get_audit_logs(limit=500)
        all_logs.extend(mongo_logs)
    except Exception as e:
        print(f"[BLOCKCHAIN] Error getting audit logs from MongoDB: {e}")

    # 2) Also grab from in-memory mock logger (may have entries that failed MongoDB write)
    if blockchain_logger and hasattr(blockchain_logger, 'get_audit_logs'):
        try:
            mock_logs = blockchain_logger.get_audit_logs()
            existing_hashes = {l.get("txHash") for l in all_logs if l.get("txHash")}
            for log in mock_logs:
                if log.get("txHash") not in existing_hashes:
                    all_logs.append(log)
                    existing_hashes.add(log.get("txHash"))
        except Exception:
            pass

    # Sort newest first
    all_logs.sort(key=lambda x: x.get("timestamp", 0), reverse=True)

    payload = {"logs": all_logs[:500], "total": len(all_logs)}
    _blockchain_logs_cache["data"] = payload
    _blockchain_logs_cache["ts"] = now

    return JSONResponse(
        content=payload,
        headers={"Cache-Control": "no-cache, no-store, must-revalidate"},
    )

# ---------------------------------------------------------------------------
# Patient endpoints — powered by MongoDB
# ---------------------------------------------------------------------------
# Internal/ML fields hidden from ALL views
_INTERNAL_COLUMNS = {"eligible", "drug_worked", "drug", "hospital_name"}

# Personal / identifying fields — shown only in the Patients tab (own hospital)
_PERSONAL_COLUMNS = [
    "patient_name", "phone", "email", "address",
    "emergency_contact", "admission_date",
]

# Columns shown in the Patients tab (own hospital) — ALL details
_PATIENT_VIEW_COLUMNS = [
    "patient_id", "patient_name", "age", "gender", "phone", "email",
    "address", "blood_group", "disease", "stage", "comorbidities",
    "bmi", "diagnosis_date", "admission_date", "emergency_contact",
]

# Columns for federated / trials view — privacy-preserving (NO personal info)
_FEDERATED_COLUMNS = [
    "patient_id", "age", "gender", "blood_group", "disease",
    "stage", "comorbidities", "bmi", "diagnosis_date",
]

@app.get("/stats")
async def get_stats(hospital: Optional[str] = None):
    """Fast lightweight stats from MongoDB aggregation.

    If *hospital* is provided, patient counts are scoped to that hospital.
    Global (federated) totals are always included for context.
    """
    try:
        stats = await db.get_patient_stats(hospital_name=hospital)
        trials = await db.get_trials_from_db()
        hospital_counts = await db.get_hospital_patient_counts()

        _log_audit(
            action="DASHBOARD_VIEWED",
            details=f"Dashboard stats accessed by {hospital or 'Unknown Hospital'} ({stats.get('total_patients', 0)} own patients, {stats.get('global_total_patients', 0)} global)",
            actor=hospital or "Unknown Hospital",
            record_count=stats.get("total_patients", 0),
        )

        return {
            "total_patients": stats.get("total_patients", 0),
            "global_total_patients": stats.get("global_total_patients", 0),
            "total_trials": len(trials),
            "total_hospitals": len(hospital_counts) or 3,
            "unique_diseases": stats.get("unique_diseases", 0),
            "drug_trials": len(trials),
            "avg_success_rate": 65.7,
            "is_training": is_training,
            "rounds_completed": len(training_logs),
            "latest_accuracy": round(training_logs[-1]["accuracy"] * 100, 1) if training_logs else None,
            "hospital_patient_counts": hospital_counts,
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/stats/hospitals")
async def get_stats_hospitals():
    """Return list of hospitals with patient counts."""
    try:
        hospitals = await db.get_hospitals()
        hospital_counts = await db.get_hospital_patient_counts()
        result = []
        for h in hospitals:
            hname = h.get("hospital_name", h.get("username", "Unknown"))
            result.append({
                "name": hname,
                "location": h.get("location", "India"),
                "status": "Active",
                "patient_count": hospital_counts.get(hname, 0),
            })
        return {"hospitals": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/stats/diseases")
async def get_stats_diseases():
    """Return disease breakdown with patient counts."""
    try:
        disease_counts = await db.get_disease_counts()
        diseases = [
            {"name": name, "count": count}
            for name, count in sorted(disease_counts.items(), key=lambda x: x[1], reverse=True)
        ]
        return {"diseases": diseases, "total": sum(d["count"] for d in diseases)}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/patients")
async def get_patients(
    hospital: Optional[str] = None,
    page: int = 1,
    page_size: int = 50,
    search: Optional[str] = None,
    sort_by: Optional[str] = None,
    sort_dir: Optional[str] = "asc",
):
    """Paginated patients from MongoDB — scoped to the requesting hospital.

    Only patients whose *hospital_name* matches the supplied *hospital*
    parameter are returned, ensuring each hospital sees only its own data.
    """
    try:
        # Log the patient view to audit trail (throttled — max once per 10s)
        if _should_log_action("PATIENTS_VIEWED"):
            try:
                if hospital:
                    hosp_count = await db.count_patients_for_hospital(hospital)
                else:
                    hosp_count = await db.count_patients()
                blockchain_logger.log_event(
                    action="PATIENTS_VIEWED",
                    details=f"Patient records accessed by {hospital or 'Unknown Hospital'} — {hosp_count} hospital records (page {page})",
                    actor=hospital or "Unknown Hospital",
                    record_count=hosp_count,
                )
            except Exception:
                pass

        result = await db.get_patients_paginated(
            page=page,
            page_size=page_size,
            search=search,
            sort_by=sort_by,
            sort_dir=sort_dir,
            hospital_name=hospital,   # <-- scope to this hospital
        )
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ---------------------------------------------------------------------------
# Eligibility helpers
# ---------------------------------------------------------------------------
def _compute_eligibility(patient: dict, trial_params: dict) -> bool:
    age = patient.get("age")
    if age is not None and trial_params.get("ageRange"):
        lo, hi = trial_params["ageRange"]
        if not (lo <= age <= hi):
            return False

    gender = patient.get("gender", "")
    allowed_genders = trial_params.get("genders", [])
    if allowed_genders and gender and gender not in allowed_genders:
        return False

    bg = patient.get("blood_group", "")
    allowed_bg = trial_params.get("bloodGroups", [])
    if allowed_bg and bg and bg not in allowed_bg:
        return False

    bmi = patient.get("bmi")
    if bmi is not None and trial_params.get("bmiRange"):
        lo, hi = trial_params["bmiRange"]
        if not (lo <= bmi <= hi):
            return False

    stage = patient.get("stage", "")
    allowed_stages = trial_params.get("stages", [])
    if allowed_stages and stage and stage not in allowed_stages:
        return False

    return True


def _build_trial_params_for_disease(all_patients, disease):
    ages, bmis, genders, blood_groups, stages, comorbidities = [], [], set(), set(), set(), []
    for p in all_patients:
        if p.get("disease", "") == disease:
            a = p.get("age")
            if a is not None: ages.append(a)
            g = p.get("gender")
            if g: genders.add(g)
            bg = p.get("blood_group")
            if bg: blood_groups.add(bg)
            b = p.get("bmi")
            if b is not None: bmis.append(b)
            s = p.get("stage")
            if s: stages.add(s)
            c = p.get("comorbidities", [])
            if isinstance(c, list):
                comorbidities.extend(c)
    comorbidity_counts = {}
    for c in comorbidities:
        comorbidity_counts[c] = comorbidity_counts.get(c, 0) + 1
    top_comorbidities = sorted(comorbidity_counts, key=comorbidity_counts.get, reverse=True)[:5]
    return {
        "ageRange": [min(ages), max(ages)] if ages else [18, 85],
        "genders": sorted(genders) if genders else ["Male", "Female"],
        "bloodGroups": sorted(blood_groups) if blood_groups else [],
        "bmiRange": [round(min(bmis), 1), round(max(bmis), 1)] if bmis else [15.0, 40.0],
        "stages": sorted(stages) if stages else [],
        "commonComorbidities": top_comorbidities,
    }

# ---------------------------------------------------------------------------
def _invalidate_trials_cache():
    """Call after data changes (upload) to force re-computation."""
    _trials_cache["data"] = None
    _trials_cache["ts"] = 0
    _eligibility_cache.clear()

# Trials endpoints — definitions from MongoDB
# ---------------------------------------------------------------------------
@app.get("/trials")
async def get_trials(hospital: Optional[str] = None):
    """Return drug trials from MongoDB with eligibility estimates (cached)."""
    import random as _rand

    now = time.time()
    if _trials_cache["data"] and (now - _trials_cache["ts"]) < _TRIALS_CACHE_TTL:
        return _trials_cache["data"]

    try:
        total_patients = await db.count_patients()
        disease_counts = await db.get_disease_counts()
        trial_defs = await db.get_trials_from_db()

        # Use a small sample for estimated eligibility (avoids loading ALL patients)
        SAMPLE_SIZE = 2000
        sample = await db.get_patient_sample(SAMPLE_SIZE)
        sample_len = len(sample)

        trials = []
        for idx, tdef in enumerate(trial_defs):
            disease = tdef["indication"]
            enrolled = disease_counts.get(disease, 0)

            elig_params = _build_trial_params_for_disease(sample, disease)

            sample_eligible = sum(1 for p in sample if _compute_eligibility(p, elig_params))
            estimated_eligible = round(sample_eligible * total_patients / sample_len) if sample_len > 0 else 0

            trials.append({
                "id": idx + 1,
                "drugName": tdef["drugName"],
                "indication": disease,
                "phase": tdef.get("phase", "Phase III"),
                "status": tdef.get("status", "Active"),
                "patientsEnrolled": enrolled,
                "successRate": tdef.get("successRate", 0),
                "startDate": "2025-01-15",
                "lastUpdate": datetime.now().strftime("%Y-%m-%d"),
                "eligibilityParams": elig_params,
                "eligibleFromCurrent": estimated_eligible,
                "sourceHospitalCount": 3,
            })

        # Log trials view to blockchain audit trail (throttled)
        _log_audit(
            action="TRIALS_VIEWED",
            details=f"Clinical trials accessed by {hospital or 'Unknown Hospital'} ({len(trials)} trials listed)",
            actor=hospital or "Unknown Hospital",
            record_count=len(trials),
        )

        result = {"trials": trials}
        _trials_cache["data"] = result
        _trials_cache["ts"] = now
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


class CreateTrialRequest(BaseModel):
    drugName: str
    indication: str
    phase: str = "Phase III"
    status: str = "Active"
    successRate: float = 0.0

@app.post("/trials")
async def create_trial(req: CreateTrialRequest, hospital: Optional[str] = None):
    """Create a new drug trial and persist to MongoDB."""
    try:
        trial_data = req.dict()
        result = await db.create_trial(trial_data)

        # Invalidate trials cache so the new trial appears immediately
        _invalidate_trials_cache()

        _log_audit(
            action="TRIAL_CREATED",
            details=f"New trial '{req.drugName}' for {req.indication} ({req.phase}) created",
            actor=hospital or "Unknown Hospital",
            cooldown=0,
        )

        return {"message": f"Trial '{req.drugName}' created successfully", "trial": result}
    except ValueError as ve:
        raise HTTPException(status_code=409, detail=str(ve))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/trials/{drug_name}/eligible")
async def get_eligible_patients_for_drug(
    drug_name: str,
    hospital: Optional[str] = None,
    page: int = 1,
    page_size: int = 50,
    tab: str = "eligible",
):
    """Check patients against trial eligibility from MongoDB."""
    try:
        page_size = min(max(page_size, 10), 200)
        page = max(page, 1)

        # Only fetch the fields needed for eligibility computation
        all_p = await db.get_all_patients_for_eligibility()

        # Build trial disease map from DB
        trial_defs = await db.get_trials_from_db()
        trial_disease_map = {t["drugName"]: t["indication"] for t in trial_defs}
        disease = trial_disease_map.get(drug_name, drug_name)
        trial_params = _build_trial_params_for_disease(all_p, disease)

        eligible_ids = []
        not_eligible_ids = []
        # Also track hospital-specific eligibility
        hospital_eligible_count = 0
        hospital_not_eligible_count = 0
        hospital_total = 0
        # Track per-hospital breakdown
        hospital_breakdown = {}
        for i, patient in enumerate(all_p):
            is_elig = _compute_eligibility(patient, trial_params)
            if is_elig:
                eligible_ids.append(i)
            else:
                not_eligible_ids.append(i)
            # Count hospital-specific numbers
            if hospital and patient.get("hospital_name") == hospital:
                hospital_total += 1
                if is_elig:
                    hospital_eligible_count += 1
                else:
                    hospital_not_eligible_count += 1
            # Per-hospital breakdown
            h_name = patient.get("hospital_name", "Unknown")
            if h_name not in hospital_breakdown:
                hospital_breakdown[h_name] = {"eligible": 0, "not_eligible": 0, "total": 0}
            hospital_breakdown[h_name]["total"] += 1
            if is_elig:
                hospital_breakdown[h_name]["eligible"] += 1
            else:
                hospital_breakdown[h_name]["not_eligible"] += 1

        eligible_count = len(eligible_ids)
        not_eligible_count = len(not_eligible_ids)

        # Log eligibility check (throttled per drug)
        elig_action_key = f"ELIGIBILITY_SCREEN_{drug_name}"
        if _should_log_action(elig_action_key):
            try:
                hosp_detail = f" | {hospital}: {hospital_eligible_count} eligible out of {hospital_total}" if hospital else ""
                blockchain_logger.log_event(
                    action="ELIGIBILITY_SCREEN",
                    details=f"{drug_name}: {eligible_count} eligible, {not_eligible_count} not eligible out of {len(all_p)} patients (federated){hosp_detail}",
                    actor=hospital or "Unknown Hospital",
                    record_count=eligible_count + not_eligible_count,
                    metadata={"drug": drug_name, "eligible": eligible_count, "not_eligible": not_eligible_count,
                              "hospital_eligible": hospital_eligible_count, "hospital_not_eligible": hospital_not_eligible_count,
                              "hospital_total": hospital_total},
                )
            except Exception:
                pass

        if tab == "eligible":
            start = (page - 1) * page_size
            end = start + page_size
            page_ids = eligible_ids[start:end]
            total_for_tab = eligible_count
        else:
            start = (page - 1) * page_size
            end = start + page_size
            page_ids = not_eligible_ids[start:end]
            total_for_tab = not_eligible_count

        page_patients_raw = [all_p[i] for i in page_ids]
        total_pages = max(1, -(-total_for_tab // page_size))

        cols = [c for c in _FEDERATED_COLUMNS if any(c in p for p in page_patients_raw[:5])]
        # Privacy-preserving: only medical/demographic fields, anonymize patient IDs
        page_patients = []
        for idx, p in enumerate(page_patients_raw):
            row = {k: p.get(k) for k in cols if k != "patient_id"}
            # Replace real patient_id with anonymous identifier
            row["patient_id"] = f"ANON-{start + idx + 1:05d}"
            page_patients.append(row)

        return {
            "drug": drug_name,
            "hospital": hospital,
            "tab": tab,
            "patients": page_patients,
            "columns": cols,
            "eligible_count": eligible_count,
            "not_eligible_count": not_eligible_count,
            "hospital_eligible_count": hospital_eligible_count,
            "hospital_not_eligible_count": hospital_not_eligible_count,
            "hospital_total": hospital_total,
            "hospital_breakdown": hospital_breakdown,
            "page": page,
            "page_size": page_size,
            "total_pages": total_pages,
            "trial_params": trial_params,
            "privacy_mode": True,
            "privacy_notice": "Patient identities are anonymized. Only medical and demographic data is shared for trial eligibility screening.",
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ---------------------------------------------------------------------------
# Upload endpoints
# ---------------------------------------------------------------------------
try:
    from preprocessing import preprocess_upload, save_standard_csv, generate_federated_training_csv
    PREPROCESSING_AVAILABLE = True
except ImportError:
    PREPROCESSING_AVAILABLE = False
    print("Warning: preprocessing module not found.")

UPLOAD_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "uploads")
CSV_ARCHIVE_DIR = os.path.join(UPLOAD_DIR, "csv_archive")

_upload_progress: Dict[str, Dict] = {}

@app.get("/upload-progress/{upload_id}")
async def get_upload_progress(upload_id: str):
    return _upload_progress.get(upload_id, {"percent": 0, "stage": "waiting"})


@app.post("/upload")
async def upload_file(file: UploadFile = File(...), hospital: Optional[str] = None):
    """Unified upload — preprocess, store in MongoDB, regenerate training CSV."""
    if not PREPROCESSING_AVAILABLE:
        raise HTTPException(status_code=500, detail="Preprocessing module not available")

    ext = os.path.splitext(file.filename)[1].lower()
    if ext not in (".csv", ".json", ".pdf"):
        raise HTTPException(status_code=400, detail="Unsupported file type. Upload CSV, JSON, or PDF.")

    content = await file.read()
    default_hospital = hospital or "Unknown Hospital"

    import uuid as _uuid
    upload_id = _uuid.uuid4().hex[:12]
    _upload_progress[upload_id] = {"percent": 5, "stage": "Reading file..."}

    try:
        _upload_progress[upload_id] = {"percent": 15, "stage": "Parsing file..."}
        df, json_structure = preprocess_upload(content, file.filename, default_hospital)
        _upload_progress[upload_id] = {"percent": 40, "stage": "Normalising columns..."}

        _upload_progress[upload_id] = {"percent": 50, "stage": "Saving standard CSV..."}
        csv_path = save_standard_csv(df, CSV_ARCHIVE_DIR, filename_prefix="patients")

        # Insert new patients into MongoDB
        _upload_progress[upload_id] = {"percent": 60, "stage": "Saving to MongoDB..."}
        new_patients_list = []
        for hosp, plist in json_structure["hospitals"].items():
            for p in plist:
                p.pop("hospital", None)
                p.pop("eligible", None)
                p.pop("drug", None)
                p.pop("drug_worked", None)
                new_patients_list.append(p)

        inserted_count = await db.insert_patients(new_patients_list, hospital_name=default_hospital)

        # Invalidate server-side caches so new data is reflected
        _invalidate_trials_cache()

        # Regenerate federated training CSV
        _upload_progress[upload_id] = {"percent": 80, "stage": "Generating training CSV..."}
        # Data is now in MongoDB — no need to regenerate CSV files
        # FL training loads directly from MongoDB via data_utils.py

        total_patients = await db.count_patients()
        new_patients = len(new_patients_list)
        hospitals_in_file = list(json_structure["hospitals"].keys())

        _upload_progress[upload_id] = {"percent": 90, "stage": "Logging to blockchain..."}
        if blockchain_logger:
            try:
                blockchain_logger.log_data_upload(
                    data_type=ext.replace(".", "").upper(),
                    source="File Upload",
                    record_count=new_patients,
                    hospitals=hospitals_in_file,
                )
            except Exception as e:
                print(f"Failed to log to blockchain: {e}")

        _upload_progress[upload_id] = {"percent": 100, "stage": "Complete"}

        return {
            "message": f"File processed successfully ({ext.upper().replace('.', '')} → MongoDB)",
            "file_type": ext.replace(".", ""),
            "new_patients": new_patients,
            "hospitals_in_file": hospitals_in_file,
            "total_patients": total_patients,
            "csv_archive": csv_path,
            "columns": [],
            "upload_id": upload_id,
        }

    except ValueError as ve:
        _upload_progress[upload_id] = {"percent": -1, "stage": f"Error: {ve}"}
        raise HTTPException(status_code=400, detail=str(ve))
    except Exception as e:
        _upload_progress[upload_id] = {"percent": -1, "stage": f"Error: {e}"}
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


# ---------------------------------------------------------------------------
# Training Management
# ---------------------------------------------------------------------------
@app.get("/training-status")
async def get_training_status():
    return {
        "is_training": is_training,
        "total_rounds": len(training_logs),
        "rounds_completed": len(training_logs),
        "latest_metrics": training_logs[-1] if training_logs else None
    }

@app.post("/start-training")
async def start_training(request: Dict[str, Any] = None):
    global is_training, training_logs

    if is_training:
        raise HTTPException(status_code=400, detail="Training already in progress")

    is_training = True
    num_rounds = request.get("num_rounds", 10) if request else 10

    _log_audit(
        action="TRAINING_STARTED",
        details=f"Federated learning training started with {num_rounds} rounds",
        actor="Training Controller",
        record_count=num_rounds,
        cooldown=0,  # always log training start
    )

    def run_training_simulation():
        global is_training, training_logs
        import random

        # Clear previous training logs in MongoDB
        try:
            sync_db = db.get_sync_db()
            sync_db.training_logs.delete_many({})
        except Exception:
            pass

        try:
            training_logs = []
            for round_num in range(1, num_rounds + 1):
                accuracy = 0.65 + (round_num / num_rounds) * 0.3 + random.uniform(-0.05, 0.05)
                accuracy = min(0.95, max(0.6, accuracy))

                loss = 0.5 - (round_num / num_rounds) * 0.3 + random.uniform(-0.05, 0.05)
                loss = max(0.1, loss)

                model_hash = f"model_r{round_num}_h{hash(str(round_num)) % 10000}"

                log_entry = {
                    "round": round_num,
                    "accuracy": round(accuracy, 4),
                    "loss": round(loss, 4),
                    "timestamp": datetime.now().isoformat(),
                    "model_hash": model_hash,
                }
                training_logs.append(log_entry)

                # Persist training log to MongoDB (sync)
                try:
                    db.insert_training_log_sync(dict(log_entry))
                except Exception as e:
                    print(f"[TRAINING] Failed to persist round {round_num} to MongoDB: {e}")

                # Enqueue to blockchain logger
                if blockchain_logger:
                    try:
                        ok, tx = blockchain_logger.enqueue_training_metadata(
                            round_number=round_num,
                            accuracy=float(accuracy),
                            model_hash=model_hash,
                        )
                    except Exception as e:
                        print(f"[TRAINING] Failed to enqueue round {round_num}: {e}")

                time.sleep(0.5)

                if not is_training:
                    break

        except Exception as e:
            print(f"Training simulation error: {e}")
        finally:
            is_training = False

    training_thread = threading.Thread(target=run_training_simulation, daemon=True)
    training_thread.start()

    return {"message": f"Training started with {num_rounds} rounds"}

@app.post("/stop-training")
async def stop_training():
    global is_training
    is_training = False
    return {"message": "Training stopped"}

@app.post("/reset-training")
async def reset_training():
    global is_training, training_logs
    is_training = False
    training_logs = []
    try:
        await db.clear_training_logs()
    except Exception:
        pass
    return {"message": "Training state reset"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8002)


================================================================================
--- FILE: .\api\__init__.py ---
================================================================================
# API module — FastAPI backend


================================================================================
--- FILE: .\blockchain\AuditLogger.sol ---
================================================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AuditLogger {
    struct TrainingLog {
        uint256 roundNumber;
        uint256 accuracy;  // Stored as accuracy * 10000 for precision
        string modelHash;
        uint256 timestamp;
    }

    TrainingLog[] public logs;

    event LogTrainingRound(
        uint256 indexed roundNumber,
        uint256 accuracy,
        string modelHash,
        uint256 timestamp
    );

    /**
     * @dev Log training metadata to blockchain
     * @param roundNumber Current federated learning round
     * @param accuracy Model accuracy (multiplied by 10000)
     * @param modelHash SHA256 hash of model parameters
     * @param timestamp Unix timestamp
     */
    function logTrainingRound(
        uint256 roundNumber,
        uint256 accuracy,
        string memory modelHash,
        uint256 timestamp
    ) public {
        logs.push(TrainingLog(roundNumber, accuracy, modelHash, timestamp));
        emit LogTrainingRound(roundNumber, accuracy, modelHash, timestamp);
    }

    /**
     * @dev Get total number of logged training rounds
     */
    function getLogCount() public view returns (uint256) {
        return logs.length;
    }

    /**
     * @dev Get training log by index
     */
    function getLog(uint256 index) public view returns (
        uint256 roundNumber,
        uint256 accuracy,
        string memory modelHash,
        uint256 timestamp
    ) {
        require(index < logs.length, "Index out of bounds");
        TrainingLog memory log = logs[index];
        return (log.roundNumber, log.accuracy, log.modelHash, log.timestamp);
    }
}

================================================================================
--- FILE: .\blockchain\FederatedTrainingLogger.sol ---
================================================================================
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title FederatedTrainingLogger
 * @dev Smart contract for logging federated learning training metadata
 * @notice Stores training round information including accuracy, model hash, and timestamp
 * @custom:security No patient data is stored - only training metadata for audit purposes
 */
contract FederatedTrainingLogger is Ownable {
    // Struct to represent a training log entry
    struct TrainingLog {
        uint256 roundNumber;
        uint256 accuracy;    // Scaled by 1000 (e.g., 0.856 = 856)
        string modelHash;
        uint256 timestamp;
    }

    // Array to store all training logs
    TrainingLog[] public trainingLogs;

    // Event emitted when a new training log is added
    event TrainingLogAdded(
        uint256 indexed roundNumber,
        uint256 accuracy,
        string modelHash,
        uint256 timestamp
    );

    /**
     * @dev Constructor - sets the contract deployer as owner
     */
    constructor() Ownable(msg.sender) {}

    /**
     * @dev Add a new training log entry
     * @param roundNumber The federated learning round number
     * @param accuracy The model accuracy scaled by 1000 (e.g., 856 for 85.6%)
     * @param modelHash SHA256 hash of the model parameters
     * @param timestamp Unix timestamp of the training round
     * @notice Only the contract owner (backend server) can call this function
     */
    function addTrainingLog(
        uint256 roundNumber,
        uint256 accuracy,
        string calldata modelHash,
        uint256 timestamp
    ) external onlyOwner {
        // Validate inputs
        require(roundNumber > 0, "Round number must be greater than 0");
        require(accuracy <= 1000, "Accuracy must be <= 1000 (100.0%)");
        require(bytes(modelHash).length == 64, "Model hash must be 64 characters (SHA256)");
        require(timestamp <= block.timestamp + 3600, "Timestamp cannot be more than 1 hour in future");

        // Create and store the log
        TrainingLog memory newLog = TrainingLog({
            roundNumber: roundNumber,
            accuracy: accuracy,
            modelHash: modelHash,
            timestamp: timestamp
        });

        trainingLogs.push(newLog);

        // Emit event
        emit TrainingLogAdded(roundNumber, accuracy, modelHash, timestamp);
    }

    /**
     * @dev Get the total number of training logs
     * @return The number of logs stored
     */
    function getLogCount() external view returns (uint256) {
        return trainingLogs.length;
    }

    /**
     * @dev Get a specific training log by index
     * @param index The index of the log to retrieve
     * @return roundNumber, accuracy, modelHash, timestamp
     */
    function getTrainingLog(uint256 index) external view returns (
        uint256 roundNumber,
        uint256 accuracy,
        string memory modelHash,
        uint256 timestamp
    ) {
        require(index < trainingLogs.length, "Index out of bounds");

        TrainingLog memory log = trainingLogs[index];
        return (log.roundNumber, log.accuracy, log.modelHash, log.timestamp);
    }

    /**
     * @dev Get multiple training logs in a single call (gas efficient for batch reading)
     * @param startIndex The starting index
     * @param count The number of logs to retrieve
     * @return Array of TrainingLog structs
     */
    function getTrainingLogs(uint256 startIndex, uint256 count) external view returns (TrainingLog[] memory) {
        require(startIndex < trainingLogs.length, "Start index out of bounds");
        require(count > 0 && count <= 50, "Count must be between 1 and 50");

        uint256 endIndex = startIndex + count;
        if (endIndex > trainingLogs.length) {
            endIndex = trainingLogs.length;
        }

        TrainingLog[] memory logs = new TrainingLog[](endIndex - startIndex);
        for (uint256 i = startIndex; i < endIndex; i++) {
            logs[i - startIndex] = trainingLogs[i];
        }

        return logs;
    }

    /**
     * @dev Get the latest training log
     * @return The most recent training log
     */
    function getLatestLog() external view returns (
        uint256 roundNumber,
        uint256 accuracy,
        string memory modelHash,
        uint256 timestamp
    ) {
        require(trainingLogs.length > 0, "No training logs available");

        TrainingLog memory latestLog = trainingLogs[trainingLogs.length - 1];
        return (latestLog.roundNumber, latestLog.accuracy, latestLog.modelHash, latestLog.timestamp);
    }

    /**
     * @dev Get logs for a specific round number
     * @param roundNumber The round number to search for
     * @return Array of indices where this round appears
     * @notice In practice, round numbers should be unique, but this allows for flexibility
     */
    function getLogsByRound(uint256 roundNumber) external view returns (uint256[] memory) {
        uint256 count = 0;

        // First pass: count matches
        for (uint256 i = 0; i < trainingLogs.length; i++) {
            if (trainingLogs[i].roundNumber == roundNumber) {
                count++;
            }
        }

        // Second pass: collect indices
        uint256[] memory indices = new uint256[](count);
        uint256 index = 0;
        for (uint256 i = 0; i < trainingLogs.length; i++) {
            if (trainingLogs[i].roundNumber == roundNumber) {
                indices[index] = i;
                index++;
            }
        }

        return indices;
    }
}

================================================================================
--- FILE: .\blockchain\logger.py ---
================================================================================
import os
import time
import json
import queue
import threading
import logging
import hashlib
import traceback
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, Any, Optional, Tuple
from dotenv import load_dotenv

# MongoDB persistence helper (imported lazily to avoid circular imports)
_db_module = None

def _get_db():
    """Lazily import the database module."""
    global _db_module
    if _db_module is None:
        try:
            import sys, importlib
            # Ensure the parent package is on the path
            parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            if parent_dir not in sys.path:
                sys.path.insert(0, parent_dir)
            _db_module = importlib.import_module("database")
        except Exception:
            _db_module = False  # mark as unavailable
    return _db_module if _db_module else None

# Load environment variables
load_dotenv()

# Expose Web3 and Account at module scope so tests can monkeypatch them.
# If the packages aren't installed, these will be None and initialization
# will fall back to the mock logger.
try:
    from web3 import Web3
    from eth_account import Account
except Exception:
    Web3 = None
    Account = None


class ConfigurationError(Exception):
    """Raised when required blockchain configuration is missing or invalid."""


def _make_logger() -> logging.Logger:
    """Create and configure a logger for the blockchain module."""
    logger = logging.getLogger("blockchain")
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter("[BLOCKCHAIN] %(levelname)s: %(message)s")
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    logger.setLevel(logging.INFO)
    return logger


logger = _make_logger()


class MockBlockchainLogger:
    """Mock logger used when blockchain is unavailable.

    Useful for development and tests; keeps raw metadata off-chain.
    Supports both training-round logs and general audit event logs.
    All logs are persisted to MongoDB.
    """

    def __init__(self) -> None:
        self._logs = []          # training round logs (in-memory cache)
        self._audit_logs = []    # general audit trail (in-memory cache)
        self.is_mock = True
        self._lock = threading.Lock()
        self._db_module = None   # Lazy-loaded database module for MongoDB
        logger.info("Using mock blockchain logger - no real blockchain connection")

        # Import database module for MongoDB persistence
        try:
            import database as _db
            self._db_module = _db
            logger.info("MongoDB persistence: enabled (all logs stored in MongoDB)")
        except ImportError:
            logger.warning("MongoDB persistence: DISABLED (database module not available)")

        class _MockW3:
            def is_connected(self_inner):
                return False

        # Provide minimal `w3` compatibility to avoid attribute errors in callers
        self.w3 = _MockW3()

    def _persist_audit_to_mongo(self, entry: dict) -> None:
        """Write a single audit log entry to MongoDB (best-effort)."""
        if self._db_module is None:
            return
        try:
            self._db_module.insert_audit_log_sync(entry)
        except Exception as e:
            logger.warning(f"Could not persist audit log to MongoDB: {e}")

    def _persist_training_to_mongo(self, entry: dict) -> None:
        """Write a single training log entry to MongoDB (best-effort)."""
        if self._db_module is None:
            return
        try:
            self._db_module.insert_training_log_sync(entry)
        except Exception as e:
            logger.warning(f"Could not persist training log to MongoDB: {e}")

    def _generate_tx_hash(self, seed: str = "") -> str:
        """Generate a realistic-looking mock transaction hash."""
        raw = f"{seed}_{time.time()}_{len(self._audit_logs)}"
        return "0x" + hashlib.sha256(raw.encode()).hexdigest()[:40]

    def enqueue(self, payload: Dict[str, Any]) -> str:
        ts = int(time.time())
        entry = {**payload, "timestamp": payload.get("timestamp", ts)}
        with self._lock:
            self._logs.append(entry)
        self._persist_training_to_mongo(entry)
        logger.info(f"Mock enqueued round {entry.get('round_number')}")
        return f"mock_tx_{entry.get('round_number')}_{ts}"

    def enqueue_training_metadata(self, round_number: int, accuracy: float, model_hash: str) -> Tuple[bool, Optional[str]]:
        """Enqueue training metadata (matches BlockchainLogger interface)."""
        try:
            ts = int(time.time())
            tx_hash = self._generate_tx_hash(f"training_{round_number}")
            entry = {
                "round_number": round_number,
                "accuracy": accuracy,
                "model_hash": model_hash,
                "timestamp": ts,
                "txHash": tx_hash,
            }
            audit_entry = {
                    "action": "TRAINING_ROUND",
                    "details": f"Round {round_number} completed — accuracy {accuracy:.4f}",
                    "actor": "FL Server",
                    "record_count": 1,
                    "timestamp": ts,
                    "txHash": tx_hash,
                    "metadata": {"round": round_number, "accuracy": accuracy, "model_hash": model_hash},
                }
            with self._lock:
                self._logs.append(entry)
                self._audit_logs.append(audit_entry)
            self._persist_training_to_mongo(entry)
            self._persist_audit_to_mongo(audit_entry)
            logger.info(f"Mock enqueued training metadata for round {round_number}")
            return True, tx_hash
        except Exception as e:
            logger.error(f"Mock enqueue failed: {e}")
            return False, str(e)

    def log_event(self, action: str, details: str = "", actor: str = "System",
                  record_count: int = 0, metadata: Dict[str, Any] = None) -> str:
        """Log a general audit event (patient upload, eligibility check, etc.)."""
        ts = int(time.time())
        tx_hash = self._generate_tx_hash(f"{action}_{details}")
        entry = {
            "action": action,
            "details": details,
            "actor": actor,
            "record_count": record_count,
            "timestamp": ts,
            "txHash": tx_hash,
            "metadata": metadata or {},
        }
        with self._lock:
            self._audit_logs.append(entry)
        self._persist_audit_to_mongo(entry)
        logger.info(f"Mock audit log: {action} — {details}")
        return tx_hash

    def log_data_upload(self, data_type: str, source: str, record_count: int,
                        hospitals: list = None) -> str:
        """Log a patient data upload event."""
        hosp_str = ", ".join(hospitals) if hospitals else "Unknown"
        return self.log_event(
            action="DATA_UPLOAD",
            details=f"{data_type} file uploaded from {source} ({record_count} records, hospitals: {hosp_str})",
            actor=source,
            record_count=record_count,
            metadata={"data_type": data_type, "hospitals": hospitals or [], "record_count": record_count},
        )

    def log_patient_action(self, action: str, patient_count: int = 0,
                           actor: str = "System", details: str = "") -> str:
        """Log a patient-related action (view, screen, predict, etc.)."""
        return self.log_event(
            action=action,
            details=details,
            actor=actor,
            record_count=patient_count,
        )

    def get_logs(self) -> list:
        with self._lock:
            return list(self._logs)

    def get_audit_logs(self) -> list:
        """Return all audit trail entries, newest first."""
        with self._lock:
            return list(reversed(self._audit_logs))

    def get_log_count(self) -> int:
        return len(self._logs)

    def get_audit_log_count(self) -> int:
        return len(self._audit_logs)

    def verify(self, onchain_hash: str, local_metadata: Dict[str, Any]) -> bool:
        """Verify provided local metadata against an on-chain hash."""
        meta_hash = BlockchainLogger.compute_metadata_hash_static(local_metadata)
        return meta_hash == onchain_hash


@dataclass
class _QueueItem:
    round_number: int
    accuracy: float
    model_hash: str
    timestamp: int
    retries: int = 0


class BlockchainLogger:
    """
    Robust Blockchain logger with async queue, retries, and verification helpers.

    Design choices / why they matter:
    - Non-blocking: enqueue metadata so FL training isn't delayed by RPC latency.
    - Hashing: store only a SHA256 of metadata on-chain to avoid exposing raw info.
    - Retries: transient RPC failures are retried with exponential backoff.
    - Strict mode: fail loudly on misconfiguration in production; dev may choose fallback.
    - Health checks and observability: startup checks and queue status help operations.
    """

    def __init__(
        self,
        strict: bool = False,
        retry_attempts: int = 3,
        receipt_timeout: int = 120,
        worker_sleep: float = 1.0,
        allow_mock_fallback: bool = True,
    ) -> None:
        """Initialize blockchain access and start background worker.

        Args:
            strict: If True, raise ConfigurationError for missing config. If False, fall back to mock.
            retry_attempts: Number of times to retry transient failures.
            receipt_timeout: Seconds to wait for transaction receipt.
            worker_sleep: Sleep between worker loop iterations.
            allow_mock_fallback: If True, will fallback to mock on init failure regardless of strict.
        """
        self.strict = strict
        self.retry_attempts = retry_attempts
        self.receipt_timeout = receipt_timeout
        self.worker_sleep = worker_sleep
        self.allow_mock_fallback = allow_mock_fallback

        self.is_mock = False
        self.w3 = None
        self.contract = None
        self.contract_address: Optional[str] = None
        self.account = None
        self.private_key: Optional[str] = None

        # Queue and worker
        self._queue: "queue.Queue[_QueueItem]" = queue.Queue()
        self._worker_thread: Optional[threading.Thread] = None
        self._stop_worker = threading.Event()

        # Track rounds to avoid duplicates (in-memory). For robust uniqueness, also check on-chain.
        self._logged_rounds = set()

        # Audit log support (persisted to MongoDB, same interface as MockBlockchainLogger)
        self._audit_logs: list = []
        self._audit_lock = threading.Lock()
        self._db_module = None
        try:
            import database as _db
            self._db_module = _db
        except ImportError:
            pass

        try:
            self._init_blockchain()
            # Start worker thread
            self._start_worker()
            logger.info("BlockchainLogger initialized successfully - REAL mode")
        except Exception as exc:
            logger.error(f"Initialization failed: {exc}")
            if strict and not allow_mock_fallback:
                raise
            logger.warning("Falling back to MockBlockchainLogger due to initialization failure")
            self.is_mock = True
            self.mock_logger = MockBlockchainLogger()

    # ----------------- Initialization helpers -----------------
    def _init_blockchain(self) -> None:
        """Load configuration, connect to provider, set up account and contract.

        Raises ConfigurationError on fatal misconfiguration.
        """
        # Ensure Web3 and Account are available (tests may monkeypatch module-level names)
        if Web3 is None or Account is None:
            raise ConfigurationError("web3 or eth_account not available")

        self.is_local = os.getenv("BLOCKCHAIN_LOCAL", "true").lower() == "true"

        # RPC provider
        if self.is_local:
            provider_url = os.getenv("BLOCKCHAIN_RPC", "http://127.0.0.1:8545")
        else:
            infura_id = os.getenv("INFURA_PROJECT_ID")
            if not infura_id:
                raise ConfigurationError("INFURA_PROJECT_ID not set for non-local network")
            provider_url = f"https://sepolia.infura.io/v3/{infura_id}"

        if not provider_url:
            raise ConfigurationError("Blockchain RPC provider URL not configured")

        logger.info(f"Connecting to blockchain RPC at {provider_url} (local={self.is_local})")
        # Use module-level Web3 (tests can monkeypatch this)
        try:
            if hasattr(Web3, "HTTPProvider"):
                provider = Web3.HTTPProvider(provider_url)
                self.w3 = Web3(provider)
            else:
                # Some tests monkeypatch `Web3` as a callable that accepts the provider URL
                self.w3 = Web3(provider_url)
        except Exception as e:
            raise ConfigurationError(f"Unable to construct Web3 provider: {e}")

        if not self.w3.is_connected():
            raise ConfigurationError(f"Unable to connect to RPC at {provider_url}")

        logger.info("Connected to blockchain RPC")

        # Private key and account
        self.private_key = os.getenv("PRIVATE_KEY")
        self._use_node_account = False

        if not self.private_key:
            # Allow using unlocked local node account when running in local mode
            if self.is_local:
                try:
                    accounts = self.w3.eth.accounts
                    if accounts:
                        addr = accounts[0]
                        # lightweight account object for address usage
                        class _A: pass
                        a = _A()
                        a.address = addr
                        self.account = a
                        self.private_key = None
                        self._use_node_account = True
                        logger.info(f"Using unlocked node account {addr} for local signing")
                    else:
                        raise ConfigurationError("No unlocked accounts available on local node and PRIVATE_KEY not set")
                except Exception as e:
                    raise ConfigurationError(f"PRIVATE_KEY not set and unable to use node account: {e}")
            else:
                raise ConfigurationError("PRIVATE_KEY not set in environment")
        else:
            # Use module-level Account (tests can monkeypatch this)
            self.account = Account.from_key(self.private_key)
            logger.info(f"Using account {self.account.address}")

        # Contract address
        self.contract_address = os.getenv("CONTRACT_ADDRESS")
        if not self.contract_address:
            raise ConfigurationError("CONTRACT_ADDRESS not set in environment")

        # Bind contract and validate ABI/function alignment
        self.contract = self._get_contract()
        logger.info(f"Using contract at {self.contract_address}")

    def _get_contract(self):
        """Create contract object and validate expected functions are present.

        This method attempts a set of known ABI shapes (AuditLogger, FederatedTrainingLogger variants)
        and selects the first one that appears to be callable on the deployed contract.
        It also records which function name should be used to append logs so callers can be agnostic
        to the specific solidity helper name used in different contract versions.
        """

        # Candidate ABIs with mapping of logical function names -> solidity function names
        candidates = [
            # AuditLogger.sol style (logTrainingRound, getLogCount, getLog)
            ({
                "abi": [
                    {
                        "inputs": [
                            {"internalType": "uint256", "name": "roundNumber", "type": "uint256"},
                            {"internalType": "uint256", "name": "accuracy", "type": "uint256"},
                            {"internalType": "string", "name": "modelHash", "type": "string"},
                            {"internalType": "uint256", "name": "timestamp", "type": "uint256"}
                        ],
                        "name": "logTrainingRound",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {"inputs": [], "name": "getLogCount", "outputs": [{"internalType": "uint256","name":"","type":"uint256"}], "stateMutability":"view","type":"function"},
                    {"inputs": [{"internalType":"uint256","name":"index","type":"uint256"}], "name":"getLog", "outputs": [
                        {"internalType":"uint256","name":"roundNumber","type":"uint256"},
                        {"internalType":"uint256","name":"accuracy","type":"uint256"},
                        {"internalType":"string","name":"modelHash","type":"string"},
                        {"internalType":"uint256","name":"timestamp","type":"uint256"}
                    ], "stateMutability":"view","type":"function"}
                ],
                "log_fn": "logTrainingRound",
                "get_log_fn": "getLog",
                "get_count_fn": "getLogCount",
            }),

            # FederatedTrainingLogger variant which exposes addTrainingLog and getTrainingLog
            ({
                "abi": [
                    {"inputs": [{"internalType":"uint256","name":"roundNumber","type":"uint256"},{"internalType":"uint256","name":"accuracy","type":"uint256"},{"internalType":"string","name":"modelHash","type":"string"},{"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"addTrainingLog","outputs":[],"stateMutability":"nonpayable","type":"function"},
                    {"inputs": [], "name": "getLogCount", "outputs": [{"internalType":"uint256","name":"","type":"uint256"}], "stateMutability":"view","type":"function"},
                    {"inputs": [{"internalType":"uint256","name":"index","type":"uint256"}], "name":"getTrainingLog", "outputs": [
                        {"internalType":"uint256","name":"roundNumber","type":"uint256"},
                        {"internalType":"uint256","name":"accuracy","type":"uint256"},
                        {"internalType":"string","name":"modelHash","type":"string"},
                        {"internalType":"uint256","name":"timestamp","type":"uint256"}
                    ], "stateMutability":"view","type":"function"}
                ],
                "log_fn": "addTrainingLog",
                "get_log_fn": "getTrainingLog",
                "get_count_fn": "getLogCount",
            }),

            # Backwards-compatible variant used in earlier code (logTrainingRound + getTrainingLog)
            ({
                "abi": [
                    {"inputs": [{"internalType":"uint256","name":"roundNumber","type":"uint256"},{"internalType":"uint256","name":"accuracy","type":"uint256"},{"internalType":"string","name":"metadataHash","type":"string"},{"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"logTrainingRound","outputs":[],"stateMutability":"nonpayable","type":"function"},
                    {"inputs": [], "name": "getLogCount", "outputs": [{"internalType":"uint256","name":"","type":"uint256"}], "stateMutability":"view","type":"function"},
                    {"inputs": [{"internalType":"uint256","name":"index","type":"uint256"}], "name": "getTrainingLog", "outputs": [
                        {"internalType":"uint256","name":"roundNumber","type":"uint256"},
                        {"internalType":"uint256","name":"accuracy","type":"uint256"},
                        {"internalType":"string","name":"metadataHash","type":"string"},
                        {"internalType":"uint256","name":"timestamp","type":"uint256"}
                    ], "stateMutability":"view","type":"function"}
                ],
                "log_fn": "logTrainingRound",
                "get_log_fn": "getTrainingLog",
                "get_count_fn": "getLogCount",
            }),
        ]

        last_err = None
        for cand in candidates:
            try:
                abi = cand["abi"]
                contract = self.w3.eth.contract(address=self.contract_address, abi=abi)

                # Quick sanity check - call getLogCount (if present) to validate contract
                get_count_fn = cand.get("get_count_fn")
                if hasattr(contract.functions, get_count_fn):
                    count = getattr(contract.functions, get_count_fn)().call()
                    logger.info(f"Contract variant `{cand.get('log_fn')}` detected: {count} existing logs")
                else:
                    logger.info(f"Contract variant `{cand.get('log_fn')}` detected (no count callable)")

                # Save the selected function names for later use
                self._log_fn_name = cand.get("log_fn")
                self._get_log_fn_name = cand.get("get_log_fn")
                self._get_count_fn_name = cand.get("get_count_fn")
                return contract
            except Exception as e:
                last_err = e
                # try next candidate
                continue

        raise ConfigurationError(f"Contract ABI mismatch or not callable at address {self.contract_address}: {last_err}")

    # ----------------- Queue & Worker -----------------
    def _start_worker(self) -> None:
        """Start background worker thread for sending transactions."""
        if self.is_mock:
            return

        if self._worker_thread and self._worker_thread.is_alive():
            return

        self._stop_worker.clear()
        self._worker_thread = threading.Thread(target=self._worker_loop, daemon=True)
        self._worker_thread.start()
        logger.info("Blockchain worker thread started")

    def stop(self, timeout: float = 5.0) -> None:
        """Stop the background worker (flushes queue while stopping)."""
        if self.is_mock:
            return
        self._stop_worker.set()
        if self._worker_thread:
            self._worker_thread.join(timeout)

    def _worker_loop(self) -> None:
        """Continuously process queued items until stopped."""
        while not self._stop_worker.is_set():
            try:
                item: _QueueItem = self._queue.get(timeout=self.worker_sleep)
            except queue.Empty:
                continue

            try:
                self._process_item(item)
            except Exception as e:
                logger.error(f"Worker failed processing item {item}: {e}")
                traceback.print_exc()
            finally:
                self._queue.task_done()

    def _process_item(self, item: _QueueItem) -> None:
        """Attempt to send a single queued transaction with retries."""
        # Check duplicate local cache
        if item.round_number in self._logged_rounds:
            logger.warning(f"Round {item.round_number} already logged locally; skipping")
            return

        for attempt in range(1, self.retry_attempts + 1):
            try:
                tx_hash = self._send_tx(item)
                logger.info(f"Transaction sent for round {item.round_number}: {tx_hash}")
                # Wait for receipt
                receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=self.receipt_timeout)
                if receipt.get("status") == 1:
                    logger.info(f"Round {item.round_number} confirmed in block {receipt.get('blockNumber')}")
                    self._logged_rounds.add(item.round_number)
                    return
                else:
                    logger.error(f"Transaction reverted for round {item.round_number}: {tx_hash}")
                    # do not retry on revert
                    return

            except Exception as e:
                logger.warning(f"Attempt {attempt} failed for round {item.round_number}: {e}")
                if attempt >= self.retry_attempts:
                    logger.error(f"Exhausted retries for round {item.round_number}")
                    return
                backoff = 2 ** (attempt - 1)
                time.sleep(backoff)

    # ----------------- Transaction building/sending -----------------
    def _send_tx(self, item: _QueueItem) -> str:
        """Build, sign and send transaction. Returns tx hash hex string."""
        # Prepare on-chain values
        accuracy_scaled = int(item.accuracy * 10000)
        metadata = {
            "round_number": item.round_number,
            "accuracy_scaled": accuracy_scaled,
            "model_hash": item.model_hash,
            "timestamp": item.timestamp,
        }

        metadata_hash = self.compute_metadata_hash_static(metadata)

        # Duplicate prevention: quick on-chain check of last log
        try:
            total = getattr(self.contract.functions, self._get_count_fn_name)().call()
            if total > 0:
                last = getattr(self.contract.functions, self._get_log_fn_name)(total - 1).call()
                last_round = int(last[0])
                if last_round == item.round_number:
                    logger.warning(f"Round {item.round_number} already on-chain according to last log; skipping send")
                    self._logged_rounds.add(item.round_number)
                    raise RuntimeError("Duplicate on-chain")
        except Exception:
            # Non-fatal: continue and attempt to send
            pass

        nonce = self.w3.eth.get_transaction_count(self.account.address)

        # estimate gas
        # Dynamically call the selected log function
        try:
            func = getattr(self.contract.functions, self._log_fn_name)
        except Exception:
            raise RuntimeError(f"Contract does not expose expected log function {getattr(self, '_log_fn_name', None)}")

        try:
            gas_est = func(
                item.round_number,
                accuracy_scaled,
                metadata_hash,
                item.timestamp,
            ).estimate_gas({"from": self.account.address})
        except Exception:
            gas_est = 200000
            logger.debug("Using fallback gas estimate 200000")

        gas_price = self.w3.eth.gas_price

        txn = func(
            item.round_number,
            accuracy_scaled,
            metadata_hash,
            item.timestamp,
        ).build_transaction({
            "from": self.account.address,
            "nonce": nonce,
            "gas": gas_est,
            "gasPrice": gas_price,
            "chainId": self.w3.eth.chain_id,
        })

        if getattr(self, '_use_node_account', False):
            # Node is expected to have unlocked accounts (Ganache/Anvil). Send raw txn via node
            try:
                tx_hash = self.w3.eth.send_transaction(txn)
                hex_hash = tx_hash.hex() if hasattr(tx_hash, 'hex') else self.w3.toHex(tx_hash)
                logger.info(f"Tx submitted via node account: {hex_hash}")
                return hex_hash
            except Exception as e:
                logger.error(f"Failed to send tx via node account: {e}")
                raise
        else:
            signed = self.w3.eth.account.sign_transaction(txn, self.private_key)
            raw = signed.rawTransaction
            tx_hash = self.w3.eth.send_raw_transaction(raw)
            hex_hash = tx_hash.hex()
            logger.info(f"Tx submitted: {hex_hash}")
            return hex_hash

    # ----------------- Public API -----------------
    def enqueue_training_metadata(self, round_number: int, accuracy: float, model_hash: str) -> Tuple[bool, Optional[str]]:
        """Enqueue metadata for asynchronous on-chain logging.

        Returns (enqueued, message_or_txid). This call is non-blocking so training can continue.
        """
        if self.is_mock:
            tx = self.mock_logger.enqueue({
                "round_number": round_number,
                "accuracy": accuracy,
                "model_hash": model_hash,
                "timestamp": int(time.time()),
            })
            return True, tx

        # Basic input validation
        if not isinstance(round_number, int) or round_number <= 0:
            return False, "invalid round"
        if not isinstance(accuracy, (float, int)) or not (0 <= accuracy <= 1):
            return False, "invalid accuracy"
        if not isinstance(model_hash, str) or len(model_hash) < 8:
            return False, "invalid model_hash"

        ts = int(time.time())
        item = _QueueItem(round_number=round_number, accuracy=float(accuracy), model_hash=model_hash, timestamp=ts)

        # Fast-path duplicate avoidance
        if round_number in self._logged_rounds:
            logger.warning(f"Round {round_number} already queued or logged; dropping request")
            return False, "duplicate"

        self._queue.put(item)
        logger.info(f"Enqueued round {round_number} for blockchain logging (queue size={self._queue.qsize()})")
        return True, None

    def flush(self, timeout: Optional[float] = None) -> None:
        """Block until queue is empty or until timeout (seconds) elapses."""
        start = time.time()
        while not self._queue.empty():
            if timeout and (time.time() - start) > timeout:
                logger.warning("Flush timeout reached before queue drained")
                return
            time.sleep(0.1)

    def get_logs(self, from_index: int = 0, max_count: int = 50) -> list:
        """Retrieve training logs from blockchain (or mock)."""
        if self.is_mock:
            return self.mock_logger.get_logs()[from_index:from_index + max_count]

        try:
            total = getattr(self.contract.functions, self._get_count_fn_name)().call()
            if from_index >= total:
                return []
            end = min(from_index + max_count, total)
            results = []
            for i in range(from_index, end):
                data = getattr(self.contract.functions, self._get_log_fn_name)(i).call()
                results.append({
                    "round_number": int(data[0]),
                    "accuracy": int(data[1]) / 10000.0,
                    "metadata_hash": data[2],
                    "timestamp": int(data[3]),
                })
            return results
        except Exception as e:
            logger.error(f"Error retrieving logs: {e}")
            return []

    def verify_onchain_hash(self, index: int, local_metadata: Dict[str, Any]) -> bool:
        """Recompute local metadata hash and compare to on-chain stored value at `index`.

        local_metadata should contain: round_number, accuracy (0-1), model_hash, timestamp
        """
        if self.is_mock:
            return self.mock_logger.verify(local_metadata.get("metadata_hash", ""), local_metadata)

        try:
            onchain = getattr(self.contract.functions, self._get_log_fn_name)(index).call()
            onchain_hash = onchain[2]
            computed = self.compute_metadata_hash_static({
                "round_number": int(local_metadata["round_number"]),
                "accuracy_scaled": int(local_metadata["accuracy"] * 10000),
                "model_hash": local_metadata["model_hash"],
                "timestamp": int(local_metadata["timestamp"]),
            })
            return onchain_hash == computed
        except Exception as e:
            logger.error(f"Verification failed: {e}")
            return False

    @staticmethod
    def compute_metadata_hash_static(metadata: Dict[str, Any]) -> str:
        """Compute SHA256 hex of canonical JSON of metadata.

        Metadata keys used: round_number, accuracy_scaled (int), model_hash, timestamp
        """
        canonical = json.dumps(
            {
                "round_number": int(metadata["round_number"]),
                "accuracy_scaled": int(metadata["accuracy_scaled"]),
                "model_hash": str(metadata["model_hash"]),
                "timestamp": int(metadata["timestamp"]),
            },
            sort_keys=True,
            separators=(",", ":"),
        )
        return hashlib.sha256(canonical.encode("utf-8")).hexdigest()

    # ----------------- Audit Logging (MongoDB-persisted) -----------------
    def _generate_tx_hash(self, seed: str = "") -> str:
        """Generate a realistic-looking transaction hash."""
        raw = f"{seed}_{time.time()}_{len(self._audit_logs)}"
        return "0x" + hashlib.sha256(raw.encode()).hexdigest()[:40]

    def _persist_audit_to_mongo(self, entry: dict) -> None:
        """Write a single audit log entry to MongoDB (best-effort)."""
        if self._db_module is None:
            return
        try:
            self._db_module.insert_audit_log_sync(entry)
        except Exception as e:
            logger.warning(f"Could not persist audit log to MongoDB: {e}")

    def log_event(self, action: str, details: str = "", actor: str = "System",
                  record_count: int = 0, metadata: Dict[str, Any] = None) -> str:
        """Log a general audit event (patient upload, eligibility check, etc.)."""
        ts = int(time.time())
        tx_hash = self._generate_tx_hash(f"{action}_{details}")
        entry = {
            "action": action,
            "details": details,
            "actor": actor,
            "record_count": record_count,
            "timestamp": ts,
            "txHash": tx_hash,
            "metadata": metadata or {},
        }
        with self._audit_lock:
            self._audit_logs.append(entry)
        self._persist_audit_to_mongo(entry)
        logger.info(f"Audit log: {action} — {details}")
        return tx_hash

    def log_data_upload(self, data_type: str, source: str, record_count: int,
                        hospitals: list = None) -> str:
        """Log a patient data upload event."""
        hosp_str = ", ".join(hospitals) if hospitals else "Unknown"
        return self.log_event(
            action="DATA_UPLOAD",
            details=f"{data_type} file uploaded from {source} ({record_count} records, hospitals: {hosp_str})",
            actor=source,
            record_count=record_count,
            metadata={"data_type": data_type, "hospitals": hospitals or [], "record_count": record_count},
        )

    def log_patient_action(self, action: str, patient_count: int = 0,
                           actor: str = "System", details: str = "") -> str:
        """Log a patient-related action (view, screen, predict, etc.)."""
        return self.log_event(
            action=action,
            details=details,
            actor=actor,
            record_count=patient_count,
        )

    def get_audit_logs(self) -> list:
        """Return all audit trail entries, newest first."""
        with self._audit_lock:
            return list(reversed(self._audit_logs))

    def get_audit_log_count(self) -> int:
        """Return total audit log count."""
        return len(self._audit_logs)

    # ----------------- Observability / Health -----------------
    def health_check(self) -> Dict[str, Any]:
        """Return a small health snapshot for startup and monitoring."""
        status = {
            "is_mock": self.is_mock,
            "queue_size": self._queue.qsize(),
            "logged_rounds_count": len(self._logged_rounds),
            "contract_address": self.contract_address,
            "connected": False,
        }
        try:
            status["connected"] = bool(self.w3 and self.w3.is_connected())
        except Exception:
            status["connected"] = False
        return status


# ----------------- Convenience factory -----------------
def get_safe_blockchain_logger(strict: bool = False):
    """Return a real `BlockchainLogger` when possible, otherwise a `MockBlockchainLogger`.

    This helper never raises; it always returns a usable logger object suitable for
    application startup where blockchain is optional.
    """
    try:
        bl = BlockchainLogger(strict=strict, allow_mock_fallback=True)
        if getattr(bl, "is_mock", False):
            return bl.mock_logger
        return bl
    except Exception as e:
        logger.warning(f"get_safe_blockchain_logger: falling back to mock due to: {e}")
        return MockBlockchainLogger()

================================================================================
--- FILE: .\blockchain\__init__.py ---
================================================================================
# Blockchain module — Smart contract logging and audit trail


================================================================================
--- FILE: .\clients\client.py ---
================================================================================
import flwr as fl
import numpy as np
from typing import Dict, List, Tuple
from model import create_model
from data_utils import load_and_preprocess_data

class MedicalClient(fl.client.NumPyClient):
    def __init__(self, client_id: int, X_train: np.ndarray, y_train: np.ndarray,
                 X_test: np.ndarray, y_test: np.ndarray, class_weights: Dict[int, float]):
        self.client_id = client_id
        self.X_train = X_train
        self.y_train = y_train
        self.X_test = X_test
        self.y_test = y_test
        self.class_weights = class_weights
        self.model = create_model(X_train.shape[1])

    def get_parameters(self, config: Dict[str, fl.common.Scalar]) -> List[np.ndarray]:
        """Return model parameters."""
        return self.model.get_weights()

    def fit(self, parameters: List[np.ndarray], config: Dict[str, fl.common.Scalar]) -> Tuple[List[np.ndarray], int, Dict[str, fl.common.Scalar]]:
        """Train the model locally."""
        self.model.set_weights(parameters)

        # Train with class weights
        self.model.fit(
            self.X_train, self.y_train,
            epochs=5,
            batch_size=16,
            verbose=0,
            class_weight=self.class_weights
        )

        return self.model.get_weights(), len(self.X_train), {}

    def evaluate(self, parameters: List[np.ndarray], config: Dict[str, fl.common.Scalar]) -> Tuple[float, int, Dict[str, fl.common.Scalar]]:
        """Evaluate the model locally."""
        self.model.set_weights(parameters)
        loss, accuracy = self.model.evaluate(self.X_test, self.y_test, verbose=0)

        return loss, len(self.X_test), {"accuracy": accuracy}

def create_clients(num_clients: int = 5) -> List[MedicalClient]:
    """
    Create simulated clients with partitioned data.

    Args:
        num_clients: Number of clients to create

    Returns:
        List of MedicalClient instances
    """
    # Load full dataset
    X_train, X_test, y_train, y_test, class_weights = load_and_preprocess_data()

    # Split training data among clients
    train_size = len(X_train) // num_clients
    clients = []

    for i in range(num_clients):
        start = i * train_size
        end = (i + 1) * train_size if i < num_clients - 1 else len(X_train)

        X_client = X_train[start:end]
        y_client = y_train[start:end]

        # Each client gets a portion of test data for local evaluation
        test_size = len(X_test) // num_clients
        test_start = i * test_size
        test_end = (i + 1) * test_size if i < num_clients - 1 else len(X_test)

        X_test_client = X_test[test_start:test_end]
        y_test_client = y_test[test_start:test_end]

        client = MedicalClient(i, X_client, y_client, X_test_client, y_test_client, class_weights)
        clients.append(client)

    return clients

def start_client(client: MedicalClient):
    """Start a Flower client."""
    fl.client.start_numpy_client(
        server_address="127.0.0.1:8080",
        client=client
    )

if __name__ == "__main__":
    # This would be run in separate processes for each client
    # For simulation, we can run multiple instances
    import sys
    if len(sys.argv) > 1:
        client_id = int(sys.argv[1])
        clients = create_clients(5)
        start_client(clients[client_id])
    else:
        print("Usage: python client.py <client_id>")

================================================================================
--- FILE: .\clients\__init__.py ---
================================================================================
# Federated Learning clients


================================================================================
--- FILE: .\fl_server\server.py ---
================================================================================
import flwr as fl
import numpy as np
from typing import Dict, List, Tuple
from datetime import datetime
import hashlib
import json
from model import create_model
from data_utils import load_and_preprocess_data
from blockchain.logger import get_safe_blockchain_logger

class FederatedServer:
    def __init__(self, num_rounds: int = 10):
        self.num_rounds = num_rounds
        self.training_logs = []
        self.blockchain_logger = get_safe_blockchain_logger()

    def evaluate_config(self, server_round: int) -> Dict[str, fl.common.Scalar]:
        """Return evaluation configuration dict for each round."""
        return {"server_round": server_round}

    def evaluate_fn(self, server_round: int, parameters: fl.common.NDArrays,
                   config: Dict[str, fl.common.Scalar]) -> Tuple[float, Dict[str, fl.common.Scalar]]:
        """
        Evaluate global model parameters using an evaluation function.
        This function is called after each round.
        """
        # Load test data
        _, X_test, _, y_test, _ = load_and_preprocess_data()

        # Ensure arrays are numpy arrays for shape access and model evaluation
        X_test = np.asarray(X_test)
        y_test = np.asarray(y_test)

        # Create model and set parameters
        input_dim = X_test.shape[1] if X_test.ndim > 1 else 1
        model = create_model(input_dim)
        if parameters:
            try:
                model.set_weights(parameters)
            except Exception:
                # Ignore weight set errors in local/dev/testing scenarios
                pass

        # Evaluate
        loss, accuracy = model.evaluate(X_test, y_test, verbose=0)

        # Generate model hash (metadata only, not weights)
        model_hash = hashlib.sha256(str(parameters).encode()).hexdigest()

        # Log to memory
        log_entry = {
            "round": server_round,
            "accuracy": float(accuracy),
            "loss": float(loss),
            "timestamp": datetime.utcnow().isoformat(),
            "model_hash": model_hash
        }
        self.training_logs.append(log_entry)

        # Log to blockchain (metadata only) - non-blocking enqueue with fallback
        try:
            if hasattr(self.blockchain_logger, "enqueue_training_metadata"):
                ok, tx = self.blockchain_logger.enqueue_training_metadata(
                    round_number=server_round,
                    accuracy=float(accuracy),
                    model_hash=model_hash
                )
                if not ok:
                    print(f"[BLOCKCHAIN] Enqueue failed for round {server_round}: {tx}")
            else:
                # Backwards-compatible synchronous call if enqueue not available
                try:
                    res = self.blockchain_logger.log_training_metadata(
                        round_number=server_round,
                        accuracy=float(accuracy),
                        model_hash=model_hash
                    )
                    print(f"[BLOCKCHAIN] Sync logging result: {res}")
                except Exception as e:
                    print(f"[BLOCKCHAIN] Sync logging error: {e}")
        except Exception as e:
            print(f"[BLOCKCHAIN] Enqueue error: {e}")

        print(f"Round {server_round}: Accuracy = {accuracy:.4f}, Loss = {loss:.4f}")

        return loss, {"accuracy": accuracy}

    def get_strategy(self) -> fl.server.strategy.Strategy:
        """Return the federated learning strategy."""
        return fl.server.strategy.FedAvg(
            min_fit_clients=5,
            min_evaluate_clients=5,
            min_available_clients=5,
            evaluate_fn=self.evaluate_fn,
            on_fit_config_fn=self.evaluate_config,
        )

    def start_server(self):
        """Start the Flower server."""
        strategy = self.get_strategy()

        # Start server
        fl.server.start_server(
            server_address="0.0.0.0:8080",
            strategy=strategy,
            config=fl.server.ServerConfig(num_rounds=self.num_rounds),
        )

if __name__ == "__main__":
    server = FederatedServer(num_rounds=10)
    server.start_server()

================================================================================
--- FILE: .\fl_server\__init__.py ---
================================================================================
# Federated Learning server


================================================================================
--- FILE: .\frontend\.env ---
================================================================================
VITE_API_BASE_URL=http://127.0.0.1:8002


================================================================================
--- FILE: .\frontend\.eslintrc.json ---
================================================================================
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended"
  ],
  "parserOptions": {
    "ecmaFeatures": {
      "jsx": true
    },
    "ecmaVersion": 12,
    "sourceType": "module"
  },
  "plugins": [
    "react",
    "react-hooks"
  ],
  "rules": {
    "react/react-in-jsx-scope": "off",
    "react/prop-types": "off"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}


================================================================================
--- FILE: .\frontend\index.html ---
================================================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Federated Drug Trial Eligibility Screener</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


================================================================================
--- FILE: .\frontend\package.json ---
================================================================================
{
  "name": "federated-screener-dashboard",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.6.0",
    "ethers": "^6.8.0",
    "framer-motion": "^12.34.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "recharts": "^2.8.0",
    "zustand": "^5.0.11"
  },
  "devDependencies": {
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.0.3",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.45.0",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.3",
    "postcss": "^8.4.29",
    "tailwindcss": "^3.3.3",
    "vite": "^4.4.5"
  }
}


================================================================================
--- FILE: .\frontend\postcss.config.js ---
================================================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================================================================================
--- FILE: .\frontend\README.md ---
================================================================================
# Federated Drug Trial Eligibility Screener - Frontend Dashboard

A React-based dashboard for monitoring federated learning training and blockchain audit logs for drug trial eligibility screening.

## Features

- **Training Controls**: Start federated learning training with configurable parameters
- **Real-time Monitoring**: Live charts showing training accuracy and loss over rounds
- **Blockchain Audit Log**: Immutable record of all training rounds stored on Ethereum
- **Responsive Design**: Modern UI built with Tailwind CSS

## Tech Stack

- **React 18** - Frontend framework
- **Vite** - Build tool and development server
- **Tailwind CSS** - Utility-first CSS framework
- **Recharts** - Chart library for data visualization
- **Axios** - HTTP client for API calls
- **Ethers.js** - Ethereum blockchain interaction

## Getting Started

### Prerequisites

- Node.js 16+ and npm
- Backend API running on `http://localhost:8000`
- Ethereum node (Ganache) running on `http://127.0.0.1:8545`

### Installation

1. Install dependencies:
```bash
npm install
```

2. Start the development server:
```bash
npm run dev
```

3. Open [http://localhost:3000](http://localhost:3000) in your browser

## Project Structure

```
src/
├── components/
│   ├── Dashboard.jsx          # Training progress charts
│   ├── TrainingControls.jsx   # Training configuration and start button
│   └── BlockchainTable.jsx    # Audit log display
├── services/
│   ├── apiService.js          # Backend API communication
│   └── blockchainService.js   # Ethereum blockchain interaction
└── App.jsx                    # Main application component
```

## API Integration

The frontend communicates with the FastAPI backend for:
- Starting training sessions
- Retrieving training logs and status
- Stopping training

## Blockchain Integration

Connects to a local Ethereum network to read audit logs from the `FederatedTrainingLogger` smart contract, ensuring transparency and immutability of training metadata.

## Development

- `npm run build` - Build for production
- `npm run preview` - Preview production build
- `npm run lint` - Run ESLint

================================================================================
--- FILE: .\frontend\tailwind.config.js ---
================================================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  theme: {
    extend: {},
  },
  plugins: [],
}

================================================================================
--- FILE: .\frontend\vite.config.js ---
================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    host: true
  }
})

================================================================================
--- FILE: .\frontend\src\App.jsx ---
================================================================================
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import LoginPage from './components/LoginPage';
import BlockchainTable from './components/BlockchainTable';
import PatientsManager from './components/PatientsManager';
import TrialsViewer from './components/TrialsViewer';
import Overview from './components/Overview';
import { ThemeToggle, ToastProvider, Button } from './components/ui';
import { useBlockchainLogs } from './hooks/useBlockchainLogs';
import { useThemeStore } from './stores/themeStore';
import { pageTransition } from './utils/motionVariants';
import { apiService } from './services/apiService';

const TABS = [
  { id: 'overview', label: 'Home', icon: 'M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-4 0h4' },
  { id: 'patients', label: 'Patients', icon: 'M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0z' },
  { id: 'trials', label: 'Clinical Trials', icon: 'M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4' },
  { id: 'blockchain', label: 'Blockchain Logs', icon: 'M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10' },
];

function App() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState(() => {
    try { return localStorage.getItem('activeTab') || 'overview'; } catch { return 'overview'; }
  });
  const [tabHistory, setTabHistory] = useState([]);
  const isDark = useThemeStore((s) => s.theme === 'dark');

  const navigateTab = (tabId) => {
    if (tabId !== activeTab) {
      setTabHistory((prev) => [...prev, activeTab]);
      setActiveTab(tabId);
      try { localStorage.setItem('activeTab', tabId); } catch { /* ignore */ }
      const tabLabel = TABS.find(t => t.id === tabId)?.label || tabId;
      apiService.logActivity('TAB_NAVIGATION', `Navigated to ${tabLabel}`, user?.hospital_name || 'Unknown Hospital');
    }
  };

  const goBack = () => {
    setTabHistory((prev) => {
      if (prev.length === 0) return prev;
      const newHistory = [...prev];
      const prevTab = newHistory.pop();
      setActiveTab(prevTab);
      try { localStorage.setItem('activeTab', prevTab); } catch { /* ignore */ }
      return newHistory;
    });
  };

  const handleLogin = (userData) => {
    setUser(userData);
    setIsAuthenticated(true);
    try { localStorage.setItem('user', JSON.stringify(userData)); localStorage.setItem('isAuthenticated', '1'); } catch { /* ignore */ }
  };

  const { logs: blockchainLogs, loading: bcLoading } = useBlockchainLogs(activeTab === 'blockchain');

  const handleLogout = () => {
    apiService.logActivity('USER_LOGOUT', `User '${user?.username}' logged out from ${user?.hospital_name}`, user?.hospital_name || 'Unknown Hospital');
    localStorage.removeItem('user');
    localStorage.removeItem('isAuthenticated');
    localStorage.removeItem('activeTab');
    setUser(null);
    setIsAuthenticated(false);
    setActiveTab('overview');
    setTabHistory([]);
  };

  useEffect(() => {
    const storedUser = localStorage.getItem('user');
    const isAuth = localStorage.getItem('isAuthenticated');
    if (storedUser && isAuth) { setUser(JSON.parse(storedUser)); setIsAuthenticated(true); }
    setLoading(false);
  }, []);

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center" style={{ background: 'var(--bg-primary)' }}>
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 mx-auto" style={{ borderBottom: '2px solid var(--brand-accent)', borderRight: '2px solid transparent' }} />
          <p className="mt-4" style={{ color: 'var(--text-tertiary)' }}>Loading...</p>
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return (
      <ToastProvider>
        <LoginPage onLogin={handleLogin} />
      </ToastProvider>
    );
  }

  return (
    <ToastProvider>
      <div className="min-h-screen" style={{ background: 'var(--bg-primary)' }}>
        {/* ── Header ── */}
        <header className="app-header">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="flex justify-between items-center h-16">
              {/* Back button + Logo */}
              <div className="flex items-center gap-3.5">
                {/* Back button */}
                {tabHistory.length > 0 && (
                  <motion.button
                    onClick={goBack}
                    className="w-9 h-9 rounded-xl flex items-center justify-center transition-all duration-200"
                    style={{
                      background: isDark ? 'rgba(32,227,178,0.08)' : 'rgba(99,102,241,0.06)',
                      border: `1px solid ${isDark ? 'rgba(32,227,178,0.15)' : 'rgba(99,102,241,0.1)'}`,
                      color: 'var(--brand-accent)',
                    }}
                    whileHover={{ scale: 1.08, x: -2 }}
                    whileTap={{ scale: 0.92 }}
                    title="Go back"
                  >
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" /></svg>
                  </motion.button>
                )}
                <button
                  onClick={() => { setActiveTab('overview'); setTabHistory([]); try { localStorage.setItem('activeTab', 'overview'); } catch {} }}
                  className="flex items-center gap-3.5 cursor-pointer bg-transparent border-none p-0 m-0 outline-none"
                  title="Go to Home"
                >
                  <div className="w-10 h-10 rounded-xl flex items-center justify-center" style={{ background: isDark ? 'linear-gradient(135deg, rgba(32,227,178,0.14), rgba(77,171,247,0.1))' : 'linear-gradient(135deg, rgba(99,102,241,0.1), rgba(14,165,233,0.08))', border: `1px solid ${isDark ? 'rgba(32,227,178,0.2)' : 'rgba(99,102,241,0.15)'}` }}>
                    <svg className="w-5 h-5" style={{ color: 'var(--brand-accent)' }} viewBox="0 0 24 24" fill="none" stroke="currentColor">
                      <path d="M12 2v20" strokeWidth="2" strokeLinecap="round" />
                      <path d="M5 7h14" strokeWidth="1.5" strokeLinecap="round" />
                      <path d="M7 12h10" strokeWidth="1.5" strokeLinecap="round" />
                    </svg>
                  </div>
                  <div className="leading-tight text-left">
                    <h1 className="text-lg font-bold tracking-tight" style={{ color: 'var(--text-primary)' }}>
                      FDT<span style={{ color: 'var(--brand-accent)' }}>ES</span>
                    </h1>
                    <p className="text-[10px] font-medium tracking-wide uppercase" style={{ color: 'var(--text-tertiary)' }}>Drug Trial Eligibility Screener</p>
                  </div>
                </button>
              </div>

              {/* Right side */}
              <div className="flex items-center gap-4">
                <ThemeToggle />
                <div className="hidden sm:flex items-center gap-3 pl-3" style={{ borderLeft: '1px solid var(--border-primary)' }}>
                  <div className="w-8 h-8 rounded-lg flex items-center justify-center text-xs font-bold" style={{ background: isDark ? 'rgba(77,171,247,0.12)' : 'rgba(99,102,241,0.08)', color: 'var(--brand-primary)' }}>
                    {user?.username?.charAt(0)?.toUpperCase() || 'U'}
                  </div>
                  <div className="text-right">
                    <p className="text-sm font-semibold leading-tight" style={{ color: 'var(--text-primary)' }}>{user?.username}</p>
                    <p className="text-[10px]" style={{ color: 'var(--text-tertiary)' }}>{user?.hospital_name}</p>
                  </div>
                </div>
                <Button variant="ghost" size="sm" onClick={handleLogout}>
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" /></svg>
                  Logout
                </Button>
              </div>
            </div>
          </div>
        </header>

        {/* ── Tab Navigation ── */}
        <nav style={{ background: 'var(--bg-header-solid)', borderBottom: '1px solid var(--border-primary)' }}>
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="flex gap-1.5 overflow-x-auto py-2.5">
              {TABS.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => navigateTab(tab.id)}
                  className={`flex items-center gap-2 py-2 px-4 font-medium text-sm whitespace-nowrap transition-all duration-200 ${activeTab === tab.id ? 'tab-active' : 'tab-inactive'}`}
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d={tab.icon} /></svg>
                  {tab.label}
                </button>
              ))}
            </div>
          </div>
        </nav>

        {/* ── Main Content ── */}
        <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 page-content">
          <AnimatePresence mode="wait">
            <motion.div key={activeTab} {...pageTransition}>
              {activeTab === 'overview' && <Overview onNavigate={navigateTab} user={user} />}
              {activeTab === 'patients' && <PatientsManager user={user} />}
              {activeTab === 'trials' && <TrialsViewer user={user} />}
              {activeTab === 'blockchain' && <BlockchainTable blockchainData={blockchainLogs} loading={bcLoading} />}
            </motion.div>
          </AnimatePresence>
        </main>
      </div>
    </ToastProvider>
  );
}

export default App;


================================================================================
--- FILE: .\frontend\src\index.css ---
================================================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* ================================================================
   DUAL-THEME CSS VARIABLES
   Light = "TechLux Platinum"  |  Dark = "BioTech Elite"
   ================================================================ */

:root,
[data-theme='light'] {
  /* Backgrounds — Premium Platinum Whites */
  --bg-primary: #F8F9FC;
  --bg-secondary: #FFFFFF;
  --bg-tertiary: #F0F2F8;
  --bg-card: #FFFFFF;
  --bg-card-hover: #FAFAFD;
  --bg-input: #F8F9FC;
  --bg-header: #FFFFFF;
  --bg-header-solid: #FFFFFF;
  --bg-login: linear-gradient(135deg, #F0F0F8 0%, #E8EAF6 35%, #F5F3FF 60%, #EEF2FF 100%);
  --bg-overlay: rgba(15, 12, 41, 0.45);
  --bg-hero-gradient: linear-gradient(135deg, rgba(99,102,241,0.04) 0%, rgba(14,165,233,0.03) 50%, rgba(168,85,247,0.04) 100%);

  /* Text — Deep Luxury Typography */
  --text-primary: #0C0F1D;
  --text-secondary: #3D4663;
  --text-tertiary: #7C839E;
  --text-inverse: #FFFFFF;

  /* Brand — Electric Indigo + Cyan Accent */
  --brand-primary: #6366F1;
  --brand-secondary: #818CF8;
  --brand-accent: #0EA5E9;
  --brand-accent-hover: #0284C7;
  --brand-gradient: linear-gradient(135deg, #6366F1, #0EA5E9);
  --brand-gradient-warm: linear-gradient(135deg, #6366F1, #A855F7);

  /* Borders — Ultra-Subtle Glass Edges */
  --border-primary: rgba(99,102,241,0.1);
  --border-secondary: rgba(99,102,241,0.18);
  --border-focus: #6366F1;
  --border-glow: 0 0 0 3px rgba(99,102,241,0.12);

  /* Shadows — Layered Premium Depth */
  --shadow-sm: 0 1px 2px rgba(99,102,241,0.04), 0 1px 3px rgba(0,0,0,0.02);
  --shadow-md: 0 4px 16px rgba(99,102,241,0.06), 0 1px 4px rgba(0,0,0,0.03);
  --shadow-lg: 0 12px 40px rgba(99,102,241,0.08), 0 4px 12px rgba(0,0,0,0.04);
  --shadow-xl: 0 20px 60px rgba(99,102,241,0.1), 0 8px 20px rgba(0,0,0,0.04);
  --shadow-glow: 0 0 20px rgba(99,102,241,0.06);
  --shadow-header: 0 1px 0 rgba(99,102,241,0.06), 0 4px 20px rgba(99,102,241,0.04);
  --shadow-card-hover: 0 12px 36px rgba(99,102,241,0.1), 0 0 0 1px rgba(99,102,241,0.05);

  /* Status — Vivid Modern Palette */
  --status-success: #10B981;
  --status-success-bg: linear-gradient(135deg, rgba(16,185,129,0.06), rgba(16,185,129,0.02));
  --status-success-bg-solid: #ECFDF5;
  --status-success-border: rgba(16,185,129,0.2);
  --status-error: #EF4444;
  --status-error-bg: linear-gradient(135deg, rgba(239,68,68,0.06), rgba(239,68,68,0.02));
  --status-error-bg-solid: #FEF2F2;
  --status-error-border: rgba(239,68,68,0.2);
  --status-warning: #F59E0B;
  --status-warning-bg: linear-gradient(135deg, rgba(245,158,11,0.06), rgba(245,158,11,0.02));
  --status-warning-bg-solid: #FFFBEB;
  --status-warning-border: rgba(245,158,11,0.2);
  --status-info: #6366F1;
  --status-info-bg: linear-gradient(135deg, rgba(99,102,241,0.06), rgba(99,102,241,0.02));
  --status-info-bg-solid: #EEF2FF;
  --status-info-border: rgba(99,102,241,0.15);

  /* Charts — Premium Gradients */
  --chart-line-1: #6366F1;
  --chart-line-2: #0EA5E9;
  --chart-line-3: #A855F7;
  --chart-area-1: rgba(99,102,241,0.08);
  --chart-area-2: rgba(14,165,233,0.06);
  --chart-grid: rgba(99,102,241,0.06);
  --chart-bg: linear-gradient(180deg, rgba(99,102,241,0.02) 0%, transparent 100%);

  /* KPI — Vibrant Premium Colors */
  --kpi-blue-bg: linear-gradient(135deg, rgba(99,102,241,0.08), rgba(99,102,241,0.03));
  --kpi-blue-bg-solid: #EEF2FF;
  --kpi-blue-text: #4F46E5;
  --kpi-blue-accent: #6366F1;
  --kpi-green-bg: linear-gradient(135deg, rgba(16,185,129,0.08), rgba(16,185,129,0.03));
  --kpi-green-bg-solid: #ECFDF5;
  --kpi-green-text: #059669;
  --kpi-green-accent: #10B981;
  --kpi-teal-bg: linear-gradient(135deg, rgba(14,165,233,0.08), rgba(14,165,233,0.03));
  --kpi-teal-bg-solid: #F0F9FF;
  --kpi-teal-text: #0284C7;
  --kpi-teal-accent: #0EA5E9;
  --kpi-purple-bg: linear-gradient(135deg, rgba(168,85,247,0.08), rgba(168,85,247,0.03));
  --kpi-purple-bg-solid: #FAF5FF;
  --kpi-purple-text: #7C3AED;
  --kpi-purple-accent: #A855F7;
  --kpi-orange-bg: linear-gradient(135deg, rgba(249,115,22,0.08), rgba(249,115,22,0.03));
  --kpi-orange-bg-solid: #FFF7ED;
  --kpi-orange-text: #EA580C;
  --kpi-orange-accent: #F97316;
  --kpi-rose-bg: linear-gradient(135deg, rgba(244,63,94,0.08), rgba(244,63,94,0.03));
  --kpi-rose-bg-solid: #FFF1F2;
  --kpi-rose-text: #E11D48;
  --kpi-rose-accent: #F43F5E;

  /* Tables — Clean Luxury Lines */
  --table-header-bg: linear-gradient(180deg, #F8F9FC, #F0F2F8);
  --table-header-bg-solid: #F5F6FA;
  --table-row-hover: rgba(99,102,241,0.03);
  --table-border: rgba(99,102,241,0.08);
  --table-row-stripe: rgba(99,102,241,0.015);

  /* Scrollbar */
  --scrollbar-track: #F0F2F8;
  --scrollbar-thumb: rgba(99,102,241,0.2);

  /* Misc */
  --radius-sm: 8px;
  --radius-md: 12px;
  --radius-lg: 16px;
  --radius-xl: 24px;
  --transition-theme: background-color 280ms cubic-bezier(0.4,0,0.2,1), color 280ms cubic-bezier(0.4,0,0.2,1), border-color 280ms cubic-bezier(0.4,0,0.2,1), box-shadow 280ms cubic-bezier(0.4,0,0.2,1);

  color-scheme: light;
}

[data-theme='dark'] {
  /* Backgrounds */
  --bg-primary: #080E1F;
  --bg-secondary: #0D1529;
  --bg-tertiary: #131D38;
  --bg-card: rgba(19, 29, 56, 0.75);
  --bg-card-hover: rgba(24, 38, 72, 0.85);
  --bg-input: rgba(19, 29, 56, 0.9);
  --bg-header: linear-gradient(180deg, rgba(8,14,31,0.97) 0%, rgba(13,21,41,0.95) 100%);
  --bg-header-solid: #0A1023;
  --bg-login: linear-gradient(135deg, #060B18 0%, #0A1023 30%, #0D1529 60%, #101B33 100%);
  --bg-overlay: rgba(0, 0, 0, 0.7);

  /* Text */
  --text-primary: #E8ECF4;
  --text-secondary: #8B9DC3;
  --text-tertiary: #5A6F94;
  --text-inverse: #0F172A;

  /* Brand */
  --brand-primary: #4DABF7;
  --brand-secondary: #339AF0;
  --brand-accent: #20E3B2;
  --brand-accent-hover: #0DD9A6;

  /* Borders */
  --border-primary: rgba(59, 82, 128, 0.35);
  --border-secondary: rgba(72, 100, 150, 0.3);
  --border-focus: #4DABF7;

  /* Shadows + Glow */
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.4);
  --shadow-md: 0 4px 14px rgba(0,0,0,0.4);
  --shadow-lg: 0 10px 30px rgba(0,0,0,0.45);
  --shadow-glow: 0 0 24px rgba(32, 227, 178, 0.06);
  --shadow-header: 0 1px 8px rgba(0,0,0,0.5);

  /* Status */
  --status-success: #20E3B2;
  --status-success-bg: rgba(32, 227, 178, 0.08);
  --status-success-border: rgba(32, 227, 178, 0.2);
  --status-error: #FF6B6B;
  --status-error-bg: rgba(255, 107, 107, 0.08);
  --status-error-border: rgba(255, 107, 107, 0.2);
  --status-warning: #FFD43B;
  --status-warning-bg: rgba(255, 212, 59, 0.08);
  --status-warning-border: rgba(255, 212, 59, 0.15);
  --status-info: #4DABF7;
  --status-info-bg: rgba(77, 171, 247, 0.08);
  --status-info-border: rgba(77, 171, 247, 0.2);

  /* Charts */
  --chart-line-1: #20E3B2;
  --chart-line-2: #4DABF7;
  --chart-grid: rgba(59, 82, 128, 0.25);

  /* KPI */
  --kpi-blue-bg: rgba(77, 171, 247, 0.1);
  --kpi-blue-text: #74C0FC;
  --kpi-green-bg: rgba(32, 227, 178, 0.08);
  --kpi-green-text: #20E3B2;
  --kpi-teal-bg: rgba(32, 227, 178, 0.06);
  --kpi-teal-text: #38D9A9;
  --kpi-purple-bg: rgba(157, 78, 221, 0.1);
  --kpi-purple-text: #C084FC;
  --kpi-orange-bg: rgba(255, 159, 67, 0.08);
  --kpi-orange-text: #FFA94D;
  --kpi-rose-bg: rgba(255, 107, 107, 0.08);
  --kpi-rose-text: #FF8787;

  /* Tables */
  --table-header-bg: rgba(13, 21, 41, 0.9);
  --table-row-hover: rgba(19, 29, 56, 0.7);
  --table-border: rgba(59, 82, 128, 0.25);
  --table-row-stripe: rgba(19, 29, 56, 0.3);

  /* Scrollbar */
  --scrollbar-track: #0D1529;
  --scrollbar-thumb: #2A3F6F;

  color-scheme: dark;
}

/* ================================================================
   BASE STYLES
   ================================================================ */
* {
  transition: var(--transition-theme);
}

canvas, video, iframe, img, svg path, svg circle, svg rect,
.no-theme-transition,
.recharts-surface,
.recharts-wrapper {
  transition: none !important;
}

html {
  scroll-behavior: smooth;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  background-color: var(--bg-primary);
  color: var(--text-primary);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  min-height: 100vh;
}

[data-theme='light'] body {
  background-image: var(--bg-hero-gradient);
  background-attachment: fixed;
}

/* Scrollbar */
::-webkit-scrollbar { width: 5px; height: 5px; }
::-webkit-scrollbar-track { background: var(--scrollbar-track); }
::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 10px; }
::-webkit-scrollbar-thumb:hover { background: var(--brand-primary); }

/* ================================================================
   GLASS CARD — Premium Frosted
   ================================================================ */
.glass-card {
  background: var(--bg-card);
  border: 1px solid var(--border-primary);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-md);
  transition: var(--transition-theme);
  position: relative;
}
[data-theme='light'] .glass-card {
  backdrop-filter: blur(24px) saturate(1.1);
  -webkit-backdrop-filter: blur(24px) saturate(1.1);
}
[data-theme='dark'] .glass-card {
  backdrop-filter: blur(20px) saturate(1.3);
  -webkit-backdrop-filter: blur(20px) saturate(1.3);
  box-shadow: var(--shadow-md), var(--shadow-glow);
}
.glass-card:hover {
  box-shadow: var(--shadow-lg);
  border-color: var(--border-secondary);
}
[data-theme='light'] .glass-card:hover {
  box-shadow: var(--shadow-card-hover);
}
[data-theme='dark'] .glass-card:hover {
  border-color: rgba(77, 171, 247, 0.15);
  box-shadow: var(--shadow-lg), 0 0 30px rgba(32, 227, 178, 0.04);
}

/* ================================================================
   HEADER — Frosted Premium Bar
   ================================================================ */
.app-header {
  background: var(--bg-header);
  border-bottom: 1px solid var(--border-primary);
  box-shadow: var(--shadow-header);
  position: sticky;
  top: 0;
  z-index: 40;
}
[data-theme='light'] .app-header {
  backdrop-filter: blur(20px) saturate(1.2);
  -webkit-backdrop-filter: blur(20px) saturate(1.2);
  background: rgba(255,255,255,0.85);
}
[data-theme='dark'] .app-header {
  backdrop-filter: blur(16px) saturate(1.4);
  -webkit-backdrop-filter: blur(16px) saturate(1.4);
}

/* ================================================================
   BUTTONS — Gradient Premium
   ================================================================ */
.btn {
  display: inline-flex; align-items: center; justify-content: center;
  gap: 0.5rem; font-weight: 600; border-radius: var(--radius-md);
  padding: 0.5rem 1.25rem; font-size: 0.875rem; cursor: pointer;
  border: none; outline: none; user-select: none; transition: all 200ms cubic-bezier(0.4,0,0.2,1);
  position: relative; overflow: hidden; letter-spacing: 0.01em;
}
.btn:active { transform: scale(0.97); }
.btn:focus-visible { outline: 2px solid var(--border-focus); outline-offset: 2px; }
.btn-primary {
  background: var(--brand-gradient);
  color: #fff;
  box-shadow: 0 4px 14px rgba(99,102,241,0.25), 0 1px 3px rgba(0,0,0,0.08);
}
[data-theme='dark'] .btn-primary {
  background: linear-gradient(135deg, #1C7ED6, #4DABF7);
  box-shadow: 0 2px 12px rgba(77,171,247,0.2);
}
.btn-primary:hover { 
  box-shadow: 0 8px 24px rgba(99,102,241,0.3), 0 2px 6px rgba(0,0,0,0.08);
  filter: brightness(1.05);
}
[data-theme='dark'] .btn-primary:hover { box-shadow: 0 4px 18px rgba(77,171,247,0.25); }
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; filter: none; box-shadow: none; }
.btn-secondary { 
  background: var(--bg-secondary); 
  color: var(--text-primary); 
  border: 1px solid var(--border-primary);
  box-shadow: var(--shadow-sm);
}
.btn-secondary:hover { background: var(--bg-card-hover); border-color: var(--border-secondary); box-shadow: var(--shadow-md); }
.btn-danger { background: transparent; color: var(--status-error); border: 1px solid var(--status-error-border); }
.btn-danger:hover { background: var(--status-error-bg-solid); }
.btn-ghost { background: transparent; color: var(--text-secondary); border-radius: var(--radius-md); }
.btn-ghost:hover { color: var(--brand-primary); background: rgba(99,102,241,0.06); }

/* ================================================================
   INPUTS — Frosted Premium
   ================================================================ */
.input {
  width: 100%; padding: 0.625rem 1rem; border-radius: var(--radius-md);
  border: 1.5px solid var(--border-primary); background: var(--bg-input);
  color: var(--text-primary); font-size: 0.875rem; outline: none; 
  transition: all 200ms cubic-bezier(0.4,0,0.2,1);
  box-shadow: var(--shadow-sm);
}
.input::placeholder { color: var(--text-tertiary); }
.input:focus { 
  border-color: var(--border-focus); 
  box-shadow: var(--border-glow);
  background: var(--bg-card);
}
[data-theme='dark'] .input:focus { box-shadow: 0 0 0 3px rgba(77,171,247,0.12); }

/* ================================================================
   BADGE — Premium Pill
   ================================================================ */
.badge {
  display: inline-flex; align-items: center; gap: 0.35rem;
  font-size: 0.7rem; font-weight: 600; padding: 0.2rem 0.65rem; border-radius: 9999px;
  letter-spacing: 0.02em;
}

/* ================================================================
   SKELETON SHIMMER
   ================================================================ */
@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}
.skeleton {
  border-radius: var(--radius-sm);
  background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-card-hover) 50%, var(--bg-tertiary) 75%);
  background-size: 200% 100%;
  animation: shimmer 1.8s ease-in-out infinite;
}

/* ================================================================
   PULSE DOT (live indicator)
   ================================================================ */
@keyframes pulse-glow {
  0%, 100% { opacity: 1; box-shadow: 0 0 4px currentColor; }
  50% { opacity: 0.5; box-shadow: 0 0 12px currentColor; }
}
@keyframes pulse-ring {
  0% { box-shadow: 0 0 0 0 currentColor; }
  50% { box-shadow: 0 0 0 3px transparent; }
}
@keyframes gradient-shift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
.pulse-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
[data-theme='dark'] .pulse-dot { animation: pulse-glow 2s ease-in-out infinite; }
[data-theme='light'] .pulse-dot { animation: pulse-ring 2s ease-in-out infinite; }

/* ================================================================
   TABLE THEME — Ultra-Clean Lines
   ================================================================ */
.themed-table { border-collapse: separate; border-spacing: 0; }
.themed-table thead { background: var(--table-header-bg-solid); }
.themed-table th {
  color: var(--text-secondary); font-size: 0.68rem; font-weight: 700;
  text-transform: uppercase; letter-spacing: 0.08em; padding: 0.7rem 0.75rem;
  border-bottom: 2px solid var(--table-border);
}
.themed-table tbody tr {
  border-bottom: 1px solid var(--table-border);
  transition: all 150ms cubic-bezier(0.4,0,0.2,1);
}
.themed-table tbody tr:nth-child(even) { background: var(--table-row-stripe); }
.themed-table tbody tr:hover { 
  background: var(--table-row-hover);
}
[data-theme='light'] .themed-table tbody tr:hover {
  box-shadow: inset 3px 0 0 var(--brand-primary);
}
.themed-table td { padding: 0.6rem 0.75rem; }

/* ================================================================
   TAB NAVIGATION — Premium Pill
   ================================================================ */
.tab-active {
  background: var(--brand-gradient);
  color: #fff !important;
  border-radius: var(--radius-md);
  box-shadow: 0 4px 14px rgba(99,102,241,0.2);
  border: 1px solid transparent;
}
[data-theme='dark'] .tab-active {
  background: linear-gradient(135deg, rgba(77,171,247,0.2), rgba(32,227,178,0.12));
  color: var(--brand-accent) !important;
  box-shadow: 0 0 12px rgba(32,227,178,0.08);
  border: 1px solid rgba(32,227,178,0.15);
}
.tab-inactive {
  color: var(--text-tertiary);
  border-radius: var(--radius-md);
  border: 1px solid transparent;
}
.tab-inactive:hover {
  color: var(--brand-primary);
  background: rgba(99,102,241,0.04);
  border-color: rgba(99,102,241,0.08);
}

/* ================================================================
   TOAST
   ================================================================ */
@keyframes toast-in { from { opacity: 0; transform: translateY(-12px) scale(0.96); } to { opacity: 1; transform: translateY(0) scale(1); } }
@keyframes toast-out { from { opacity: 1; transform: translateY(0) scale(1); } to { opacity: 0; transform: translateY(-12px) scale(0.96); } }
.toast-enter { animation: toast-in 300ms ease forwards; }
.toast-exit { animation: toast-out 250ms ease forwards; }

/* ================================================================
   MISC
   ================================================================ */
:focus-visible { outline: 2px solid var(--brand-primary); outline-offset: 2px; }
button { background: transparent; border: none; padding: 0; font: inherit; color: inherit; cursor: pointer; }

/* Alert / info banners */
.info-banner {
  padding: 0.65rem 0.85rem;
  border-radius: var(--radius-md);
  font-size: 0.8125rem;
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
  line-height: 1.5;
}

/* Decorative accent bar */
.accent-bar {
  width: 4px;
  border-radius: 4px;
  background: var(--brand-gradient);
  flex-shrink: 0;
}

/* Section header with accent */
.section-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.section-header .accent-bar { height: 1.25rem; }

/* Stat card gradient border on hover */
.stat-card {
  border-radius: var(--radius-lg);
  padding: 1rem;
  position: relative;
  overflow: hidden;
  transition: all 200ms cubic-bezier(0.4,0,0.2,1);
}
[data-theme='light'] .stat-card::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 3px;
  background: var(--brand-gradient);
  opacity: 0;
  transition: opacity 250ms ease;
}
[data-theme='light'] .stat-card:hover::before { opacity: 1; }

/* Mini chart container */
.mini-chart-container {
  border-radius: var(--radius-md);
  padding: 0.5rem;
  background: var(--chart-bg);
}

/* Page transition wrapper */
.page-content { min-height: calc(100vh - 140px); }


================================================================================
--- FILE: .\frontend\src\main.jsx ---
================================================================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'

// Initialize theme from store before first render to prevent flash
import { useThemeStore } from './stores/themeStore'
useThemeStore.getState() // triggers store init → applyThemeToDOM

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)


================================================================================
--- FILE: .\frontend\src\components\BlockchainTable.jsx ---
================================================================================
import React, { memo, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Card, TableSkeleton } from './ui';
import { useThemeStore } from '../stores/themeStore';
import { staggerContainer, staggerItem } from '../utils/motionVariants';

const formatTimestamp = (t) => {
  if (!t) return '-';
  const ms = t > 1e12 ? t : t * 1000;
  return new Date(ms).toLocaleString();
};

const ACTION_ICONS = {
  SYSTEM_STARTUP:        '⚡',
  USER_LOGIN:            '🔑',
  LOGIN_FAILED:          '🚫',
  USER_LOGOUT:           '🚪',
  DASHBOARD_VIEWED:      '🏠',
  DATA_UPLOAD:           '📤',
  PATIENTS_VIEWED:       '👁️',
  TRIALS_VIEWED:         '📊',
  ELIGIBILITY_SCREEN:    '🔍',
  ELIGIBILITY_PREDICTION:'🎯',
  TRAINING_STARTED:      '🚀',
  TRAINING_ROUND:        '🔄',
  TAB_NAVIGATION:        '📍',
};

const getActionIcon = (action) => ACTION_ICONS[action] || '📋';

const BlockchainTable = memo(function BlockchainTable({ blockchainData = [], loading = false }) {
  const data = Array.isArray(blockchainData) ? blockchainData : [];
  const isDark = useThemeStore((s) => s.theme === 'dark');

  // Performance: only animate the first 20 rows, render rest instantly
  const ANIMATE_LIMIT = 20;

  // Memoize action summary counts
  const actionSummary = useMemo(() => {
    const counts = {};
    for (const entry of data) {
      const a = entry.action || 'UNKNOWN';
      counts[a] = (counts[a] || 0) + 1;
    }
    return counts;
  }, [data]);

  return (
    <motion.div variants={staggerContainer} initial="hidden" animate="visible">
      <motion.div variants={staggerItem}>
        <Card padding="p-6">
          <div className="flex items-center justify-between mb-4">
            <div>
              <div className="flex items-center gap-2">
                <div className="w-1.5 h-6 rounded-full" style={{ background: 'var(--brand-primary)' }} />
                <h2 className="text-xl font-bold" style={{ color: 'var(--text-primary)' }}>Blockchain Audit Log</h2>
              </div>
              <p className="text-sm mt-0.5" style={{ color: 'var(--text-tertiary)' }}>Immutable record of all system actions</p>
            </div>
            <div className="flex items-center gap-3">
              {loading && <div className="animate-spin rounded-full h-4 w-4" style={{ borderBottom: '2px solid var(--brand-primary)' }} />}
              <span
                className="badge"
                style={{ background: 'var(--bg-tertiary)', color: 'var(--text-secondary)', border: '1px solid var(--border-primary)' }}
              >
                {data.length} entries
              </span>
            </div>
          </div>

          {/* Legend with counts */}
          <div className="flex flex-wrap gap-2 mb-4">
            {Object.entries(ACTION_ICONS).map(([key, icon]) => {
              const count = actionSummary[key] || 0;
              return (
                <span
                  key={key}
                  className="badge text-[11px]"
                  style={{
                    background: count > 0 ? 'var(--status-info-bg)' : 'var(--bg-tertiary)',
                    color: count > 0 ? 'var(--status-info)' : 'var(--text-tertiary)',
                    border: `1px solid ${count > 0 ? 'var(--status-info-border)' : 'var(--border-primary)'}`,
                  }}
                >
                  <span>{icon}</span>
                  <span>{key.replace(/_/g, ' ')}</span>
                  {count > 0 && <span className="font-bold ml-1">({count})</span>}
                </span>
              );
            })}
          </div>

          {loading && data.length === 0 ? (
            <TableSkeleton cols={6} rows={5} />
          ) : data.length === 0 ? (
            <div className="py-12 text-center">
              <div className="text-4xl mb-3">🔗</div>
              <p className="font-medium" style={{ color: 'var(--text-secondary)' }}>No blockchain audit entries yet</p>
              <p className="text-sm mt-1" style={{ color: 'var(--text-tertiary)' }}>Upload patient data or navigate the app to generate audit entries</p>
            </div>
          ) : (
            <div className="overflow-x-auto" style={{ border: '1px solid var(--table-border)', borderRadius: 'var(--radius-md)' }}>
                <table className="min-w-full w-full table-auto text-left themed-table">
                  <thead>
                    <tr>
                      <th className="px-3 py-2.5">Action</th>
                      <th className="px-3 py-2.5">Details</th>
                      <th className="px-3 py-2.5">Actor</th>
                      <th className="px-3 py-2.5">Timestamp</th>
                      <th className="px-3 py-2.5">Tx Hash</th>
                    </tr>
                  </thead>
                  <tbody>
                    <AnimatePresence>
                      {data.map((entry, idx) => {
                        const shouldAnimate = idx < ANIMATE_LIMIT;
                        return (
                        <motion.tr
                          key={entry.txHash || idx}
                          initial={shouldAnimate ? { opacity: 0, x: -8 } : false}
                          animate={{ opacity: 1, x: 0 }}
                          transition={shouldAnimate ? { delay: idx * 0.015, duration: 0.15 } : { duration: 0 }}
                        >
                          <td className="px-3 py-3 align-top">
                            <span
                              className="badge"
                              style={{ background: 'var(--status-info-bg)', color: 'var(--status-info)', border: '1px solid var(--status-info-border)' }}
                            >
                              <span>{getActionIcon(entry.action)}</span>
                              <span>{(entry.action || 'UNKNOWN').replace(/_/g, ' ')}</span>
                            </span>
                          </td>
                          <td className="px-3 py-3 align-top text-sm max-w-xs truncate" style={{ color: 'var(--text-primary)' }} title={entry.details}>{entry.details || '-'}</td>
                          <td className="px-3 py-3 align-top text-sm" style={{ color: 'var(--text-secondary)' }}>{entry.actor || '-'}</td>
                          <td className="px-3 py-3 align-top text-sm whitespace-nowrap" style={{ color: 'var(--text-tertiary)' }}>{formatTimestamp(entry.timestamp)}</td>
                          <td className="px-3 py-3 align-top text-xs font-mono" style={{ color: 'var(--text-tertiary)' }}>
                            {entry.txHash ? (
                              <span title={entry.txHash} className="cursor-help" style={{ color: 'var(--brand-primary)' }}>
                                {entry.txHash.slice(0, 10)}…{entry.txHash.slice(-6)}
                              </span>
                            ) : '-'}
                          </td>
                        </motion.tr>
                        );
                      })}
                    </AnimatePresence>
                  </tbody>
                </table>
            </div>
          )}

          {/* Privacy note */}
          <div
            className="mt-4 p-3 rounded-lg text-sm flex items-start gap-2"
            style={{ background: 'var(--status-info-bg)', border: '1px solid var(--status-info-border)', color: 'var(--status-info)' }}
          >
            <svg className="w-5 h-5 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
            <span><strong>Blockchain Audit:</strong> Every action is logged with a cryptographic hash for tamper-proof auditability. In production, these entries are written to an on-chain smart contract.</span>
          </div>
        </Card>
      </motion.div>
    </motion.div>
  );
});

export default BlockchainTable;

================================================================================
--- FILE: .\frontend\src\components\LoginPage.jsx ---
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { apiService } from '../services/apiService';
import { Button, ThemeToggle } from './ui';
import { useThemeStore } from '../stores/themeStore';

/* ── Animated floating particles (enhanced) ── */
const Particle = ({ delay, size, x, y, duration, color }) => (
  <motion.div
    className="absolute rounded-full pointer-events-none"
    style={{
      width: size, height: size, left: `${x}%`, top: `${y}%`,
      background: color || 'var(--brand-accent)', opacity: 0,
      filter: 'blur(1px)',
    }}
    animate={{
      opacity: [0, 0.5, 0],
      y: [0, -80, -160],
      x: [0, Math.sin(delay) * 20, 0],
      scale: [0.3, 1.2, 0.2],
    }}
    transition={{ duration, delay, repeat: Infinity, ease: 'easeInOut' }}
  />
);

/* ── Premium DNA helix decoration ── */
const DNAHelix = () => (
  <svg className="absolute opacity-[0.05] pointer-events-none" style={{ right: '-5%', top: '10%', width: '180px', height: '80%' }} viewBox="0 0 100 400">
    {Array.from({ length: 20 }).map((_, i) => {
      const y = i * 20;
      const x1 = 30 + Math.sin(i * 0.6) * 20;
      const x2 = 70 - Math.sin(i * 0.6) * 20;
      return (
        <g key={i}>
          <circle cx={x1} cy={y} r="3" fill="var(--brand-accent)" />
          <circle cx={x2} cy={y} r="3" fill="var(--brand-primary)" />
          <line x1={x1} y1={y} x2={x2} y2={y} stroke="var(--border-primary)" strokeWidth="1" opacity="0.5" />
        </g>
      );
    })}
  </svg>
);

/* ── Animated counter stat ── */
const AnimatedStat = ({ value, label, suffix = '', delay = 0 }) => {
  const [count, setCount] = useState(0);
  useEffect(() => {
    const timer = setTimeout(() => {
      let start = 0;
      const end = parseInt(value);
      const increment = Math.ceil(end / 40);
      const counter = setInterval(() => {
        start += increment;
        if (start >= end) {
          setCount(end);
          clearInterval(counter);
        } else {
          setCount(start);
        }
      }, 30);
      return () => clearInterval(counter);
    }, delay);
    return () => clearTimeout(timer);
  }, [value, delay]);

  return (
    <motion.div
      className="text-center"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: delay / 1000 + 0.5, duration: 0.5 }}
    >
      <div className="text-2xl font-black tabular-nums" style={{ color: 'var(--brand-accent)' }}>
        {count.toLocaleString()}{suffix}
      </div>
      <div className="text-[10px] font-semibold uppercase tracking-[0.15em] mt-1" style={{ color: 'var(--text-tertiary)' }}>
        {label}
      </div>
    </motion.div>
  );
};

/* ── Floating grid pattern ── */
const GridPattern = ({ isDark }) => (
  <div className="absolute inset-0 pointer-events-none overflow-hidden opacity-[0.03]">
    <svg width="100%" height="100%">
      <defs>
        <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
          <path d="M 40 0 L 0 0 0 40" fill="none" stroke={isDark ? '#20E3B2' : '#6366F1'} strokeWidth="0.5" />
        </pattern>
      </defs>
      <rect width="100%" height="100%" fill="url(#grid)" />
    </svg>
  </div>
);

export default function LoginPage({ onLogin }) {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [focusField, setFocusField] = useState(null);
  const isDark = useThemeStore((s) => s.theme === 'dark');

  const handleLogin = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    if (!username || !password) {
      setError('Please enter both username and password');
      setLoading(false);
      return;
    }

    try {
      const result = await apiService.login(username, password);
      const user = result.user;
      localStorage.setItem('user', JSON.stringify(user));
      localStorage.setItem('isAuthenticated', 'true');
      onLogin(user);
    } catch (err) {
      setError(err.message || 'Login failed. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const fillCredentials = (u, p) => {
    setUsername(u);
    setPassword(p);
    setError('');
  };

  const demoUsers = [
    { user: 'SaiPrasad24S', pass: '2724', label: 'Sai Prasad', icon: '🏥' },
    { user: 'Apollo', pass: 'apollo9', label: 'Apollo', icon: '🏥' },
    { user: 'KIMS', pass: 'kims8', label: 'KIMS', icon: '🏥' },
    { user: 'Medicover', pass: 'medicover5', label: 'Medicover', icon: '🏥' },
    { user: 'Citizens', pass: 'citizens4', label: 'Citizens', icon: '🏥' },
  ];

  return (
    <div className="min-h-screen flex relative overflow-hidden" style={{ background: 'var(--bg-login)' }}>
      {/* ── Grid Pattern ── */}
      <GridPattern isDark={isDark} />

      {/* ── Enhanced Floating particles ── */}
      {Array.from({ length: 12 }).map((_, i) => (
        <Particle
          key={i}
          delay={i * 0.9}
          size={3 + (i % 4) * 2}
          x={5 + i * 8}
          y={15 + (i % 5) * 16}
          duration={5 + i * 0.4}
          color={i % 3 === 0 ? 'var(--brand-primary)' : 'var(--brand-accent)'}
        />
      ))}

      {/* ── DNA Helix ── */}
      <DNAHelix />

      {/* ── Theme Toggle ── */}
      <div className="absolute top-5 right-5 z-20">
        <ThemeToggle />
      </div>

      {/* ── Left branding panel (desktop only) ── */}
      <div className="hidden lg:flex lg:w-[45%] flex-col justify-center items-center relative p-12">
        {/* Glowing orb */}
        <div className="absolute w-[300px] h-[300px] rounded-full opacity-10 blur-[80px] pointer-events-none"
          style={{ background: 'var(--brand-accent)', top: '30%', left: '20%' }} />

        <motion.div
          className="relative z-10 max-w-md"
          initial={{ opacity: 0, x: -40 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.8, ease: 'easeOut' }}
        >
          {/* Logo */}
          <motion.div
            className="w-20 h-20 rounded-3xl flex items-center justify-center mb-8"
            style={{
              background: isDark
                ? 'linear-gradient(135deg, rgba(32,227,178,0.15), rgba(77,171,247,0.1))'
                : 'linear-gradient(135deg, rgba(99,102,241,0.12), rgba(14,165,233,0.08))',
              border: `1.5px solid ${isDark ? 'rgba(32,227,178,0.25)' : 'rgba(99,102,241,0.2)'}`,
              boxShadow: isDark ? '0 0 40px rgba(32,227,178,0.1)' : '0 0 40px rgba(99,102,241,0.08)',
            }}
            whileHover={{ scale: 1.05, rotate: 3 }}
          >
            <svg className="w-10 h-10" style={{ color: 'var(--brand-accent)' }} viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path d="M12 2v20" strokeWidth="2" strokeLinecap="round" />
              <path d="M5 7h14" strokeWidth="1.5" strokeLinecap="round" />
              <path d="M7 12h10" strokeWidth="1.5" strokeLinecap="round" />
              <path d="M9 17h6" strokeWidth="1.5" strokeLinecap="round" />
            </svg>
          </motion.div>

          <h1 className="text-5xl font-black tracking-tight leading-tight" style={{ color: 'var(--text-primary)' }}>
            FDT<span style={{ color: 'var(--brand-accent)' }}>ES</span>
          </h1>
          <p className="text-lg font-medium mt-3 leading-relaxed" style={{ color: 'var(--text-secondary)' }}>
            Federated Drug Trial<br />Eligibility Screener
          </p>
          <p className="text-sm mt-4 leading-relaxed" style={{ color: 'var(--text-tertiary)' }}>
            Federated learning platform enabling multi-hospital drug trial screening without exposing patient data.
          </p>

          {/* Feature pills */}
          <div className="flex flex-wrap gap-2.5 mt-8">
            {['Federated Learning', 'Blockchain Audit', 'Privacy-First'].map((tag) => (
              <motion.span
                key={tag}
                className="px-4 py-2 rounded-full text-xs font-bold uppercase tracking-wider"
                style={{
                  background: isDark ? 'rgba(32,227,178,0.08)' : 'rgba(99,102,241,0.06)',
                  color: 'var(--brand-accent)',
                  border: `1px solid ${isDark ? 'rgba(32,227,178,0.18)' : 'rgba(99,102,241,0.12)'}`,
                }}
                whileHover={{ scale: 1.05 }}
              >
                {tag}
              </motion.span>
            ))}
          </div>

          {/* Trust indicators */}
          <div className="flex items-center gap-6 mt-8">
            <div className="flex items-center gap-2">
              <div className="w-2 h-2 rounded-full animate-pulse" style={{ background: '#10B981' }} />
              <span className="text-xs font-medium" style={{ color: 'var(--text-tertiary)' }}>System Online</span>
            </div>
            <div className="flex items-center gap-2">
              <svg className="w-3.5 h-3.5" style={{ color: 'var(--text-tertiary)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
              </svg>
              <span className="text-xs font-medium" style={{ color: 'var(--text-tertiary)' }}>End-to-End Encrypted</span>
            </div>
            <div className="flex items-center gap-2">
              <svg className="w-3.5 h-3.5" style={{ color: 'var(--text-tertiary)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
              </svg>
              <span className="text-xs font-medium" style={{ color: 'var(--text-tertiary)' }}>HIPAA Compliant</span>
            </div>
          </div>
        </motion.div>
      </div>

      {/* ── Right login panel ── */}
      <div className="flex-1 flex items-center justify-center p-6 lg:p-12">
        <motion.div
          className="w-full max-w-[440px]"
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6, delay: 0.15, ease: 'easeOut' }}
        >
          {/* Premium glass card with animated border */}
          <div className="relative rounded-3xl overflow-hidden group">
            {/* Animated border glow */}
            <div className="absolute -inset-[1px] rounded-3xl opacity-60 group-hover:opacity-100 transition-opacity duration-500" style={{
              background: isDark
                ? 'linear-gradient(135deg, rgba(32,227,178,0.3), rgba(77,171,247,0.2), rgba(168,85,247,0.2), rgba(32,227,178,0.3))'
                : 'linear-gradient(135deg, rgba(99,102,241,0.2), rgba(14,165,233,0.15), rgba(168,85,247,0.15), rgba(99,102,241,0.2))',
              backgroundSize: '300% 300%',
              animation: 'gradient-shift 4s ease infinite',
            }} />
            <div
              className="relative rounded-3xl overflow-hidden"
              style={{
                background: isDark ? 'rgba(13,21,41,0.92)' : 'rgba(255,255,255,0.92)',
                backdropFilter: 'blur(32px) saturate(200%)',
                boxShadow: isDark
                  ? '0 30px 80px rgba(0,0,0,0.6), 0 0 0 1px rgba(32,227,178,0.08) inset, 0 1px 0 rgba(255,255,255,0.03) inset'
                  : '0 30px 80px rgba(99,102,241,0.1), 0 0 0 1px rgba(99,102,241,0.06) inset, 0 1px 0 rgba(255,255,255,0.8) inset',
              }}
            >
            {/* Top accent line */}
            <div className="h-[2px] w-full" style={{
              background: isDark
                ? 'linear-gradient(90deg, transparent, #20E3B2, #4DABF7, transparent)'
                : 'linear-gradient(90deg, transparent, #6366F1, #0EA5E9, transparent)',
            }} />

            <div className="p-8 sm:p-10">
              {/* Mobile-only header */}
              <div className="lg:hidden text-center mb-8">
                <motion.div
                  className="mx-auto w-16 h-16 rounded-2xl flex items-center justify-center mb-4"
                  style={{
                    background: isDark
                      ? 'linear-gradient(135deg, rgba(32,227,178,0.12), rgba(77,171,247,0.08))'
                      : 'linear-gradient(135deg, rgba(99,102,241,0.1), rgba(14,165,233,0.06))',
                    border: `1.5px solid ${isDark ? 'rgba(32,227,178,0.2)' : 'rgba(99,102,241,0.15)'}`,
                  }}
                  whileHover={{ scale: 1.05, rotate: 5 }}
                >
                  <svg className="w-8 h-8" style={{ color: 'var(--brand-accent)' }} viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M12 2v20" strokeWidth="2" strokeLinecap="round" />
                    <path d="M5 7h14" strokeWidth="1.5" strokeLinecap="round" />
                    <path d="M7 12h10" strokeWidth="1.5" strokeLinecap="round" />
                  </svg>
                </motion.div>
                <h1 className="text-3xl font-black" style={{ color: 'var(--text-primary)' }}>
                  FDT<span style={{ color: 'var(--brand-accent)' }}>ES</span>
                </h1>
                <p className="text-sm mt-1" style={{ color: 'var(--text-tertiary)' }}>Federated Drug Trial Eligibility Screener</p>
              </div>

              {/* Sign In header (desktop) */}
              <div className="hidden lg:block mb-8">
                <h2 className="text-2xl font-black" style={{ color: 'var(--text-primary)' }}>Welcome Back</h2>
                <p className="text-sm mt-1" style={{ color: 'var(--text-tertiary)' }}>Sign in to access the platform</p>
              </div>

              {/* Quick access badges */}
              <div className="mb-6">
                <p className="text-[10px] font-bold uppercase tracking-[0.12em] mb-3" style={{ color: 'var(--text-tertiary)' }}>Quick Access</p>
                <div className="grid grid-cols-4 gap-2">
                  {demoUsers.map((d) => (
                    <motion.button
                      key={d.user}
                      type="button"
                      onClick={() => fillCredentials(d.user, d.pass)}
                      className="flex flex-col items-center gap-1.5 py-2.5 px-2 rounded-xl text-center transition-all"
                      style={{
                        background: username === d.user
                          ? (isDark ? 'rgba(32,227,178,0.1)' : 'rgba(99,102,241,0.08)')
                          : 'var(--bg-tertiary)',
                        border: `1px solid ${username === d.user ? (isDark ? 'rgba(32,227,178,0.3)' : 'rgba(99,102,241,0.2)') : 'var(--border-primary)'}`,
                      }}
                      whileHover={{ scale: 1.04 }}
                      whileTap={{ scale: 0.97 }}
                    >
                      <span className="text-lg">{d.icon}</span>
                      <span className="text-[10px] font-bold truncate w-full" style={{ color: 'var(--text-secondary)' }}>{d.label}</span>
                    </motion.button>
                  ))}
                </div>
              </div>

              {/* Divider */}
              <div className="flex items-center gap-3 mb-6">
                <div className="flex-1 h-px" style={{ background: 'var(--border-primary)' }} />
                <span className="text-[10px] font-bold uppercase tracking-widest" style={{ color: 'var(--text-tertiary)' }}>or enter credentials</span>
                <div className="flex-1 h-px" style={{ background: 'var(--border-primary)' }} />
              </div>

              {/* Error */}
              <AnimatePresence>
                {error && (
                  <motion.div
                    className="mb-5 p-3.5 rounded-xl text-sm flex items-center gap-2.5"
                    style={{ background: 'var(--status-error-bg)', border: '1px solid var(--status-error-border)', color: 'var(--status-error)' }}
                    initial={{ opacity: 0, y: -8, height: 0 }}
                    animate={{ opacity: 1, y: 0, height: 'auto' }}
                    exit={{ opacity: 0, y: -8, height: 0 }}
                  >
                    <svg className="w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    {error}
                  </motion.div>
                )}
              </AnimatePresence>

              {/* Form */}
              <form onSubmit={handleLogin} className="space-y-5">
                {/* Username */}
                <div>
                  <label className="block text-xs font-bold uppercase tracking-wider mb-2" style={{ color: 'var(--text-tertiary)' }}>Username</label>
                  <div className="relative">
                    <div className="absolute left-3.5 top-1/2 -translate-y-1/2" style={{ color: focusField === 'user' ? 'var(--brand-accent)' : 'var(--text-tertiary)' }}>
                      <svg className="w-4.5 h-4.5 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                      </svg>
                    </div>
                    <input
                      type="text"
                      value={username}
                      onChange={(e) => { setUsername(e.target.value); setError(''); }}
                      onFocus={() => setFocusField('user')}
                      onBlur={() => setFocusField(null)}
                      placeholder="Enter your username"
                      className="input pl-11"
                      disabled={loading}
                      autoComplete="username"
                      style={{
                        borderColor: focusField === 'user' ? (isDark ? 'rgba(32,227,178,0.4)' : 'rgba(99,102,241,0.35)') : undefined,
                        boxShadow: focusField === 'user' ? (isDark ? '0 0 0 3px rgba(32,227,178,0.08)' : '0 0 0 3px rgba(99,102,241,0.06)') : undefined,
                      }}
                    />
                  </div>
                </div>

                {/* Password */}
                <div>
                  <label className="block text-xs font-bold uppercase tracking-wider mb-2" style={{ color: 'var(--text-tertiary)' }}>Password</label>
                  <div className="relative">
                    <div className="absolute left-3.5 top-1/2 -translate-y-1/2" style={{ color: focusField === 'pass' ? 'var(--brand-accent)' : 'var(--text-tertiary)' }}>
                      <svg className="w-4.5 h-4.5 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                      </svg>
                    </div>
                    <input
                      type={showPassword ? 'text' : 'password'}
                      value={password}
                      onChange={(e) => { setPassword(e.target.value); setError(''); }}
                      onFocus={() => setFocusField('pass')}
                      onBlur={() => setFocusField(null)}
                      placeholder="Enter your password"
                      className="input pl-11 pr-11"
                      disabled={loading}
                      autoComplete="current-password"
                      style={{
                        borderColor: focusField === 'pass' ? (isDark ? 'rgba(32,227,178,0.4)' : 'rgba(99,102,241,0.35)') : undefined,
                        boxShadow: focusField === 'pass' ? (isDark ? '0 0 0 3px rgba(32,227,178,0.08)' : '0 0 0 3px rgba(99,102,241,0.06)') : undefined,
                      }}
                    />
                    <button
                      type="button"
                      onClick={() => setShowPassword(!showPassword)}
                      className="absolute right-3.5 top-1/2 -translate-y-1/2 transition-colors"
                      style={{ color: 'var(--text-tertiary)' }}
                      tabIndex={-1}
                    >
                      {showPassword ? (
                        <svg className="w-4.5 h-4.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21" /></svg>
                      ) : (
                        <svg className="w-4.5 h-4.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>
                      )}
                    </button>
                  </div>
                </div>

                {/* Sign in button */}
                <motion.div whileTap={{ scale: 0.985 }}>
                  <button
                    type="submit"
                    disabled={loading}
                    className="w-full py-3.5 rounded-xl font-bold text-sm tracking-wide transition-all duration-300 flex items-center justify-center gap-2.5 relative overflow-hidden group/btn"
                    style={{
                      background: isDark
                        ? 'linear-gradient(135deg, #20E3B2, #0DD9A6, #4DABF7)'
                        : 'linear-gradient(135deg, #6366F1, #4F46E5, #7C3AED)',
                      backgroundSize: '200% 200%',
                      animation: !loading ? 'gradient-shift 3s ease infinite' : 'none',
                      color: isDark ? '#0A1023' : '#FFFFFF',
                      boxShadow: isDark
                        ? '0 4px 24px rgba(32,227,178,0.35), 0 0 0 1px rgba(32,227,178,0.1) inset'
                        : '0 4px 24px rgba(99,102,241,0.3), 0 0 0 1px rgba(255,255,255,0.1) inset',
                      opacity: loading ? 0.8 : 1,
                    }}
                  >
                    {loading ? (
                      <>
                        <div className="w-4 h-4 border-2 rounded-full animate-spin"
                          style={{ borderColor: 'transparent', borderTopColor: isDark ? '#0A1023' : '#fff' }} />
                        Authenticating...
                      </>
                    ) : (
                      <>
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1" />
                        </svg>
                        Sign In to Platform
                      </>
                    )}
                  </button>
                </motion.div>
              </form>

              {/* Security footer */}
              <div className="mt-8 flex flex-col items-center gap-3">
                <div className="flex items-center gap-4">
                  <div className="flex items-center gap-1.5">
                    <svg className="w-3.5 h-3.5" style={{ color: 'var(--brand-accent)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
                    </svg>
                    <span className="text-[10px] font-semibold" style={{ color: 'var(--text-tertiary)' }}>Secured</span>
                  </div>
                  <div className="w-px h-3" style={{ background: 'var(--border-primary)' }} />
                  <div className="flex items-center gap-1.5">
                    <svg className="w-3.5 h-3.5" style={{ color: 'var(--brand-accent)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                    </svg>
                    <span className="text-[10px] font-semibold" style={{ color: 'var(--text-tertiary)' }}>Blockchain</span>
                  </div>
                  <div className="w-px h-3" style={{ background: 'var(--border-primary)' }} />
                  <div className="flex items-center gap-1.5">
                    <svg className="w-3.5 h-3.5" style={{ color: 'var(--brand-accent)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                    </svg>
                    <span className="text-[10px] font-semibold" style={{ color: 'var(--text-tertiary)' }}>HIPAA Ready</span>
                  </div>
                </div>
                <p className="text-[10px]" style={{ color: 'var(--text-tertiary)', opacity: 0.6 }}>&copy; 2026 FDTES Platform. All rights reserved.</p>
              </div>
            </div>
          </div>
          </div>
        </motion.div>
      </div>
    </div>
  );
}



================================================================================
--- FILE: .\frontend\src\components\Overview.jsx ---
================================================================================
import React, { useState, useEffect, memo, useMemo, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { PieChart, Pie, Cell, ResponsiveContainer, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, AreaChart, Area } from 'recharts';
import { apiService } from '../services/apiService';
import { Card, StatusBadge, Skeleton } from './ui';
import { useThemeStore } from '../stores/themeStore';
import { staggerContainer, staggerItem } from '../utils/motionVariants';

const CHART_COLORS = ['#6366F1', '#0EA5E9', '#A855F7', '#10B981', '#F97316', '#F43F5E'];

/* ── Premium KPI Card (Clickable) ── */
const KPICard = memo(function KPICard({ icon, iconBg, iconColor, label, value, trend, accentColor, onClick, isActive, actionLabel }) {
  return (
    <motion.div variants={staggerItem} whileHover={{ scale: 1.025 }} whileTap={{ scale: 0.98 }}>
      <Card hover>
        <button
          onClick={onClick}
          className="w-full text-left focus:outline-none group"
          style={{ cursor: 'pointer' }}
        >
          <div className="flex items-start justify-between">
            <div className="flex items-center gap-3.5">
              <div className="w-12 h-12 rounded-2xl flex items-center justify-center flex-shrink-0 transition-transform duration-300 group-hover:scale-110" style={{ background: iconBg, color: iconColor }}>
                {icon}
              </div>
              <div className="min-w-0">
                <p className="text-[10px] font-bold uppercase tracking-[0.1em]" style={{ color: 'var(--text-tertiary)' }}>{label}</p>
                <p className="text-2xl font-black tabular-nums mt-0.5" style={{ color: 'var(--text-primary)' }}>{value}</p>
              </div>
            </div>
            {trend != null && (
              <span className="badge text-[10px]" style={{
                background: trend > 0 ? 'var(--kpi-green-bg-solid)' : 'var(--kpi-rose-bg-solid)',
                color: trend > 0 ? 'var(--kpi-green-text)' : 'var(--kpi-rose-text)',
                border: `1px solid ${trend > 0 ? 'var(--status-success-border)' : 'var(--status-error-border)'}`,
              }}>
                {trend > 0 ? '↑' : '↓'} {Math.abs(trend)}%
              </span>
            )}
          </div>
          <div className="mt-3 h-1 rounded-full overflow-hidden" style={{ background: 'var(--bg-tertiary)' }}>
            <motion.div className="h-full rounded-full" style={{ background: accentColor || 'var(--brand-gradient)' }}
              initial={{ width: 0 }} animate={{ width: '100%' }} transition={{ duration: 1.2, ease: 'easeOut', delay: 0.2 }} />
          </div>
          {actionLabel && (
            <p className="mt-2.5 text-[10px] font-semibold uppercase tracking-wider flex items-center gap-1.5 transition-colors"
              style={{ color: isActive ? (accentColor || 'var(--brand-accent)') : 'var(--text-tertiary)' }}>
              <span className="transition-transform duration-200 group-hover:translate-x-0.5">{actionLabel}</span>
              <svg className="w-3 h-3 transition-transform duration-200 group-hover:translate-x-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M9 5l7 7-7 7" /></svg>
            </p>
          )}
        </button>
      </Card>
    </motion.div>
  );
});

/* ── Custom Chart Tooltip ── */
const ChartTooltip = ({ active, payload, label }) => {
  if (!active || !payload?.length) return null;
  return (
    <div className="glass-card p-3 text-xs" style={{ border: '1px solid var(--border-secondary)', boxShadow: 'var(--shadow-lg)' }}>
      <p className="font-bold mb-1" style={{ color: 'var(--text-primary)' }}>{label}</p>
      {payload.map((p, i) => (
        <p key={i} style={{ color: p.color }}>{p.name}: <strong>{typeof p.value === 'number' ? p.value.toLocaleString() : p.value}</strong></p>
      ))}
    </div>
  );
};

/* ── Workflow Step ── */
const WorkflowStep = memo(function WorkflowStep({ step, title, desc, icon, color }) {
  return (
    <motion.div className="relative" variants={staggerItem}>
      <div className="flex flex-col items-center text-center">
        <div className="w-14 h-14 rounded-2xl flex items-center justify-center mb-3" style={{ background: color + '10', color, border: `1.5px solid ${color}20` }}>
          {icon}
        </div>
        <div className="w-6 h-6 rounded-full flex items-center justify-center text-xs font-black mb-2" style={{ background: color, color: '#fff' }}>{step}</div>
        <p className="font-bold text-sm" style={{ color: 'var(--text-primary)' }}>{title}</p>
        <p className="text-xs mt-1.5 leading-relaxed max-w-[200px]" style={{ color: 'var(--text-secondary)' }}>{desc}</p>
      </div>
    </motion.div>
  );
});

export default function Overview({ onNavigate, user }) {
  const [stats, setStats] = useState({ totalPatients: 0, globalTotalPatients: 0, totalTrials: 0, totalHospitals: 0, successRate: 0, uniqueDiseases: 0, drugTrials: 0 });
  const [loadingStats, setLoadingStats] = useState(true);
  const [trainingStatus, setTrainingStatus] = useState(null);
  const [activeDetail, setActiveDetail] = useState(null);
  const [hospitalData, setHospitalData] = useState(null);
  const [diseaseData, setDiseaseData] = useState(null);
  const [detailLoading, setDetailLoading] = useState(false);
  const isDark = useThemeStore((s) => s.theme === 'dark');
  const hospitalName = user?.hospital_name || '';

  useEffect(() => {
    let mounted = true;
    const loadOverviewData = async () => {
      try {
        setLoadingStats(true);
        const data = await apiService.getStats(hospitalName);
        if (!mounted) return;
        setStats({
          totalPatients: data.total_patients || 0,
          globalTotalPatients: data.global_total_patients || data.total_patients || 0,
          totalTrials: data.total_trials || 0,
          totalHospitals: data.total_hospitals || 0,
          successRate: data.avg_success_rate || 0,
          uniqueDiseases: data.unique_diseases || 0,
          drugTrials: data.drug_trials || 0,
        });
        setTrainingStatus({
          is_training: data.is_training,
          rounds_completed: data.rounds_completed || 0,
          latest_metrics: data.latest_accuracy ? { accuracy: data.latest_accuracy / 100 } : null,
        });
      } catch (err) {
        console.error('Error loading overview data:', err);
      } finally {
        if (mounted) setLoadingStats(false);
      }
    };
    loadOverviewData();
    return () => { mounted = false; };
  }, [hospitalName]);

  /* ── KPI Click Handlers ── */
  const handleKPIClick = useCallback(async (kpiKey) => {
    // Navigate to tab for tab-mapped KPIs
    if (kpiKey === 'patients' || kpiKey === 'trials' || kpiKey === 'drugTrials') {
      if (onNavigate) onNavigate(kpiKey === 'drugTrials' ? 'trials' : kpiKey);
      return;
    }
    // Toggle detail panel for non-tab KPIs
    if (activeDetail === kpiKey) {
      setActiveDetail(null);
      return;
    }
    setActiveDetail(kpiKey);
    setDetailLoading(true);
    try {
      if (kpiKey === 'hospitals' && !hospitalData) {
        const data = await apiService.getHospitalDetails();
        setHospitalData(data.hospitals || []);
      }
      if (kpiKey === 'diseases' && !diseaseData) {
        const data = await apiService.getDiseaseBreakdown();
        setDiseaseData(data.diseases || []);
      }
    } catch (err) {
      console.error('Error fetching detail:', err);
    } finally {
      setDetailLoading(false);
    }
  }, [activeDetail, hospitalData, diseaseData, onNavigate]);

  /* ── Computed chart data ── */
  const distributionData = useMemo(() => [
    { name: 'Patients', value: stats.totalPatients || 1, color: CHART_COLORS[0] },
    { name: 'Active Trials', value: stats.totalTrials || 1, color: CHART_COLORS[1] },
    { name: 'Hospitals', value: stats.totalHospitals || 1, color: CHART_COLORS[2] },
    { name: 'Diseases', value: stats.uniqueDiseases || 1, color: CHART_COLORS[3] },
  ], [stats]);

  const barData = useMemo(() => [
    { name: 'Patients', value: stats.totalPatients, fill: CHART_COLORS[0] },
    { name: 'Trials', value: stats.totalTrials, fill: CHART_COLORS[1] },
    { name: 'Hospitals', value: stats.totalHospitals, fill: CHART_COLORS[2] },
    { name: 'Diseases', value: stats.uniqueDiseases, fill: CHART_COLORS[3] },
    { name: 'Drugs', value: stats.drugTrials, fill: CHART_COLORS[4] },
  ], [stats]);

  const trendData = useMemo(() => {
    const base = stats.totalPatients || 100;
    return ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day, i) => ({
      day,
      patients: Math.round(base * (0.7 + Math.sin(i * 0.8) * 0.15 + i * 0.04)),
      screenings: Math.round((stats.totalTrials || 5) * (2 + Math.sin(i * 1.2) * 1.5 + i * 0.5)),
    }));
  }, [stats]);

  if (loadingStats) {
    return (
      <div className="space-y-4">
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
          {Array.from({ length: 6 }).map((_, i) => (
            <div key={i} className="glass-card p-5"><Skeleton rows={2} height="h-5" /></div>
          ))}
        </div>
      </div>
    );
  }

  const kpis = [
    { key: 'patients', icon: <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0z" /></svg>, iconBg: 'var(--kpi-blue-bg-solid)', iconColor: 'var(--kpi-blue-text)', label: 'My Patients', value: stats.totalPatients.toLocaleString(), trend: 12, accentColor: 'var(--kpi-blue-accent)', actionLabel: 'View Patients' },
    { key: 'globalPatients', icon: <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>, iconBg: 'var(--kpi-teal-bg-solid)', iconColor: 'var(--kpi-teal-text)', label: 'Global Patients (Federated)', value: stats.globalTotalPatients.toLocaleString(), trend: null, accentColor: 'var(--kpi-teal-accent)', actionLabel: 'Federated Pool' },
    { key: 'trials', icon: <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>, iconBg: 'var(--kpi-green-bg-solid)', iconColor: 'var(--kpi-green-text)', label: 'Active Trials', value: stats.totalTrials, trend: 8, accentColor: 'var(--kpi-green-accent)', actionLabel: 'View Trials' },
    { key: 'hospitals', icon: <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" /></svg>, iconBg: 'var(--kpi-purple-bg-solid)', iconColor: 'var(--kpi-purple-text)', label: 'Hospitals', value: stats.totalHospitals, trend: null, accentColor: 'var(--kpi-purple-accent)', actionLabel: 'View Hospitals' },
    { key: 'diseases', icon: <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" /></svg>, iconBg: 'var(--kpi-orange-bg-solid)', iconColor: 'var(--kpi-orange-text)', label: 'Unique Diseases', value: stats.uniqueDiseases, trend: 3, accentColor: 'var(--kpi-orange-accent)', actionLabel: 'View Diseases' },
    { key: 'drugTrials', icon: <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.8} d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" /></svg>, iconBg: 'var(--kpi-rose-bg-solid)', iconColor: 'var(--kpi-rose-text)', label: 'Drug Trials', value: stats.drugTrials, trend: -2, accentColor: 'var(--kpi-rose-accent)', actionLabel: 'View Drug Trials' },
  ];

  return (
    <motion.div className="space-y-6" variants={staggerContainer} initial="hidden" animate="visible">
      {/* KPI Grid */}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
        {kpis.map((k) => (
          <KPICard
            key={k.label}
            icon={k.icon}
            iconBg={k.iconBg}
            iconColor={k.iconColor}
            label={k.label}
            value={k.value}
            trend={k.trend}
            accentColor={k.accentColor}
            actionLabel={k.actionLabel}
            isActive={activeDetail === k.key}
            onClick={() => handleKPIClick(k.key)}
          />
        ))}
      </div>

      {/* ── Detail Panel ── */}
      <AnimatePresence mode="wait">
        {activeDetail && (
          <motion.div
            key={activeDetail}
            initial={{ opacity: 0, height: 0, y: -10 }}
            animate={{ opacity: 1, height: 'auto', y: 0 }}
            exit={{ opacity: 0, height: 0, y: -10 }}
            transition={{ duration: 0.35, ease: 'easeInOut' }}
          >
            <Card>
              <div className="flex items-center justify-between mb-5">
                <div className="section-header mb-0">
                  <div className="accent-bar" style={{
                    background: activeDetail === 'hospitals' ? 'var(--kpi-purple-accent)' :
                      activeDetail === 'diseases' ? 'var(--kpi-orange-accent)' : 'var(--kpi-teal-accent)'
                  }} />
                  <h3 className="text-sm font-bold" style={{ color: 'var(--text-primary)' }}>
                    {activeDetail === 'hospitals' && 'Hospital Network'}
                    {activeDetail === 'diseases' && 'Disease Distribution'}
                    {activeDetail === 'successRate' && 'Success Rate Analysis'}
                  </h3>
                </div>
                <button onClick={() => setActiveDetail(null)} className="w-8 h-8 rounded-lg flex items-center justify-center transition-colors"
                  style={{ background: 'var(--bg-tertiary)', color: 'var(--text-secondary)' }}>
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
              </div>

              {detailLoading ? (
                <Skeleton rows={3} height="h-5" />
              ) : (
                <>
                  {/* ── Hospitals Detail ── */}
                  {activeDetail === 'hospitals' && hospitalData && (
                    <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                      {hospitalData.map((h, idx) => (
                        <motion.div key={h.name} initial={{ opacity: 0, y: 12 }} animate={{ opacity: 1, y: 0 }} transition={{ delay: idx * 0.1 }}
                          className="rounded-2xl p-5 text-center" style={{ background: 'var(--bg-secondary)', border: `1.5px solid ${h.name === hospitalName ? 'var(--brand-accent)' : 'var(--border-primary)'}` }}>
                          <div className="w-14 h-14 rounded-2xl flex items-center justify-center mx-auto mb-3"
                            style={{ background: CHART_COLORS[idx % CHART_COLORS.length] + '18', color: CHART_COLORS[idx % CHART_COLORS.length], border: `1.5px solid ${CHART_COLORS[idx % CHART_COLORS.length]}25` }}>
                            <svg className="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" /></svg>
                          </div>
                          <p className="font-bold text-sm" style={{ color: 'var(--text-primary)' }}>{h.name}</p>
                          {h.name === hospitalName && <span className="text-[10px] font-bold px-2 py-0.5 rounded-full" style={{ background: 'var(--brand-accent)', color: '#fff' }}>YOU</span>}
                          <p className="text-xs mt-1" style={{ color: 'var(--text-tertiary)' }}>{h.location}</p>
                          <p className="text-lg font-black mt-2 tabular-nums" style={{ color: CHART_COLORS[idx % CHART_COLORS.length] }}>{(h.patient_count || 0).toLocaleString()}</p>
                          <p className="text-[10px] font-medium" style={{ color: 'var(--text-tertiary)' }}>patients</p>
                          <div className="mt-3 inline-flex items-center gap-1.5 px-3 py-1 rounded-full text-[10px] font-bold"
                            style={{ background: 'var(--kpi-green-bg-solid)', color: 'var(--kpi-green-text)', border: '1px solid var(--status-success-border)' }}>
                            <span className="w-1.5 h-1.5 rounded-full" style={{ background: 'var(--kpi-green-text)' }} />
                            {h.status}
                          </div>
                        </motion.div>
                      ))}
                    </div>
                  )}

                  {/* ── Diseases Detail ── */}
                  {activeDetail === 'diseases' && diseaseData && (
                    <div className="space-y-3">
                      {diseaseData.length === 0 ? (
                        <p className="text-sm text-center py-6" style={{ color: 'var(--text-tertiary)' }}>No disease data available</p>
                      ) : (
                        diseaseData.slice(0, 12).map((d, idx) => {
                          const maxCount = Math.max(...diseaseData.map(x => x.count));
                          const pct = maxCount > 0 ? (d.count / maxCount) * 100 : 0;
                          return (
                            <motion.div key={d.name} initial={{ opacity: 0, x: -12 }} animate={{ opacity: 1, x: 0 }} transition={{ delay: idx * 0.05 }}
                              className="flex items-center gap-4">
                              <span className="text-xs font-semibold w-40 truncate" style={{ color: 'var(--text-primary)' }} title={d.name}>{d.name}</span>
                              <div className="flex-1 h-3 rounded-full overflow-hidden" style={{ background: 'var(--bg-tertiary)' }}>
                                <motion.div className="h-full rounded-full" initial={{ width: 0 }} animate={{ width: `${pct}%` }}
                                  transition={{ duration: 0.8, ease: 'easeOut', delay: idx * 0.05 }}
                                  style={{ background: CHART_COLORS[idx % CHART_COLORS.length] }} />
                              </div>
                              <span className="text-xs font-black tabular-nums w-12 text-right" style={{ color: 'var(--text-secondary)' }}>{d.count}</span>
                            </motion.div>
                          );
                        })
                      )}
                      {diseaseData.length > 12 && (
                        <p className="text-[11px] text-center mt-2" style={{ color: 'var(--text-tertiary)' }}>
                          + {diseaseData.length - 12} more diseases
                        </p>
                      )}
                    </div>
                  )}

                  {/* ── Success Rate Detail ── */}
                  {activeDetail === 'successRate' && (
                    <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                      <motion.div initial={{ opacity: 0, scale: 0.9 }} animate={{ opacity: 1, scale: 1 }} transition={{ delay: 0 }}
                        className="flex flex-col items-center justify-center rounded-2xl p-6" style={{ background: 'var(--bg-secondary)', border: '1px solid var(--border-primary)' }}>
                        <div className="relative w-28 h-28">
                          <svg className="w-full h-full -rotate-90" viewBox="0 0 100 100">
                            <circle cx="50" cy="50" r="42" fill="none" stroke="var(--bg-tertiary)" strokeWidth="10" />
                            <motion.circle cx="50" cy="50" r="42" fill="none" stroke="#10B981" strokeWidth="10" strokeLinecap="round"
                              strokeDasharray={264} initial={{ strokeDashoffset: 264 }}
                              animate={{ strokeDashoffset: 264 - (264 * stats.successRate / 100) }}
                              transition={{ duration: 1.5, ease: 'easeOut' }} />
                          </svg>
                          <div className="absolute inset-0 flex items-center justify-center">
                            <span className="text-2xl font-black" style={{ color: 'var(--text-primary)' }}>{stats.successRate}%</span>
                          </div>
                        </div>
                        <p className="text-xs font-bold mt-3" style={{ color: 'var(--text-secondary)' }}>Overall Success Rate</p>
                      </motion.div>
                      <motion.div initial={{ opacity: 0, scale: 0.9 }} animate={{ opacity: 1, scale: 1 }} transition={{ delay: 0.1 }}
                        className="stat-card flex flex-col items-center justify-center text-center rounded-2xl p-6" style={{ background: 'var(--kpi-blue-bg-solid)' }}>
                        <p className="text-[10px] font-bold uppercase tracking-[0.1em]" style={{ color: 'var(--kpi-blue-text)' }}>Total Screenings</p>
                        <p className="text-3xl font-black mt-2 tabular-nums" style={{ color: 'var(--kpi-blue-text)' }}>{stats.totalPatients}</p>
                        <p className="text-[11px] mt-1" style={{ color: 'var(--kpi-blue-text)', opacity: 0.7 }}>patients screened</p>
                      </motion.div>
                      <motion.div initial={{ opacity: 0, scale: 0.9 }} animate={{ opacity: 1, scale: 1 }} transition={{ delay: 0.2 }}
                        className="stat-card flex flex-col items-center justify-center text-center rounded-2xl p-6" style={{ background: 'var(--kpi-green-bg-solid)' }}>
                        <p className="text-[10px] font-bold uppercase tracking-[0.1em]" style={{ color: 'var(--kpi-green-text)' }}>Active Trials</p>
                        <p className="text-3xl font-black mt-2 tabular-nums" style={{ color: 'var(--kpi-green-text)' }}>{stats.totalTrials}</p>
                        <p className="text-[11px] mt-1" style={{ color: 'var(--kpi-green-text)', opacity: 0.7 }}>in progress</p>
                      </motion.div>
                    </div>
                  )}
                </>
              )}
            </Card>
          </motion.div>
        )}
      </AnimatePresence>

      {/* ── Charts Row ── */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
        {/* Weekly Activity Trend — Area Chart */}
        <motion.div variants={staggerItem}>
          <Card>
            <div className="section-header mb-4">
              <div className="accent-bar" />
              <h3 className="text-sm font-bold" style={{ color: 'var(--text-primary)' }}>Weekly Activity Trend</h3>
            </div>
            <div className="h-56 no-theme-transition mini-chart-container">
              <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={trendData} margin={{ top: 8, right: 8, left: -20, bottom: 0 }}>
                  <defs>
                    <linearGradient id="gradPatients" x1="0" y1="0" x2="0" y2="1">
                      <stop offset="0%" stopColor="#6366F1" stopOpacity={0.2} />
                      <stop offset="100%" stopColor="#6366F1" stopOpacity={0} />
                    </linearGradient>
                    <linearGradient id="gradScreenings" x1="0" y1="0" x2="0" y2="1">
                      <stop offset="0%" stopColor="#0EA5E9" stopOpacity={0.15} />
                      <stop offset="100%" stopColor="#0EA5E9" stopOpacity={0} />
                    </linearGradient>
                  </defs>
                  <CartesianGrid strokeDasharray="3 3" stroke="var(--chart-grid)" vertical={false} />
                  <XAxis dataKey="day" tick={{ fill: 'var(--text-tertiary)', fontSize: 11 }} axisLine={false} tickLine={false} />
                  <YAxis tick={{ fill: 'var(--text-tertiary)', fontSize: 11 }} axisLine={false} tickLine={false} />
                  <Tooltip content={<ChartTooltip />} />
                  <Area type="monotone" dataKey="patients" name="Patients" stroke="#6366F1" strokeWidth={2.5} fill="url(#gradPatients)" dot={false} />
                  <Area type="monotone" dataKey="screenings" name="Screenings" stroke="#0EA5E9" strokeWidth={2} fill="url(#gradScreenings)" dot={false} />
                </AreaChart>
              </ResponsiveContainer>
            </div>
          </Card>
        </motion.div>

        {/* Platform Statistics — Donut + Bar */}
        <motion.div variants={staggerItem}>
          <Card>
            <div className="section-header mb-4">
              <div className="accent-bar" />
              <h3 className="text-sm font-bold" style={{ color: 'var(--text-primary)' }}>Platform Statistics</h3>
            </div>
            <div className="grid grid-cols-2 gap-2">
              <div className="h-56 no-theme-transition mini-chart-container flex items-center justify-center">
                <ResponsiveContainer width="100%" height="100%">
                  <PieChart>
                    <Pie data={distributionData} cx="50%" cy="50%" innerRadius="55%" outerRadius="80%" paddingAngle={4} dataKey="value" stroke="none">
                      {distributionData.map((entry, idx) => <Cell key={idx} fill={entry.color} />)}
                    </Pie>
                    <Tooltip content={<ChartTooltip />} />
                  </PieChart>
                </ResponsiveContainer>
              </div>
              <div className="h-56 no-theme-transition mini-chart-container">
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart data={barData} margin={{ top: 8, right: 4, left: -28, bottom: 0 }}>
                    <CartesianGrid strokeDasharray="3 3" stroke="var(--chart-grid)" vertical={false} />
                    <XAxis dataKey="name" tick={{ fill: 'var(--text-tertiary)', fontSize: 9 }} axisLine={false} tickLine={false} />
                    <YAxis tick={{ fill: 'var(--text-tertiary)', fontSize: 10 }} axisLine={false} tickLine={false} />
                    <Tooltip content={<ChartTooltip />} />
                    <Bar dataKey="value" name="Count" radius={[6, 6, 0, 0]}>
                      {barData.map((entry, idx) => <Cell key={idx} fill={entry.fill} />)}
                    </Bar>
                  </BarChart>
                </ResponsiveContainer>
              </div>
            </div>
            <div className="flex flex-wrap gap-3 mt-3 px-1">
              {distributionData.map((d) => (
                <div key={d.name} className="flex items-center gap-1.5 text-[11px]">
                  <div className="w-2.5 h-2.5 rounded-full" style={{ background: d.color }} />
                  <span style={{ color: 'var(--text-secondary)' }}>{d.name}</span>
                  <span className="font-bold" style={{ color: 'var(--text-primary)' }}>{d.value}</span>
                </div>
              ))}
            </div>
          </Card>
        </motion.div>
      </div>

      {/* Model training status */}
      {trainingStatus && trainingStatus.rounds_completed > 0 && (
        <motion.div variants={staggerItem}>
          <Card>
            <div className="section-header mb-4">
              <div className="accent-bar" style={{ background: 'var(--kpi-green-accent)' }} />
              <h3 className="text-sm font-bold" style={{ color: 'var(--text-primary)' }}>Model Status</h3>
              <StatusBadge status={trainingStatus.is_training ? 'Training' : 'Ready'} />
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
              <div className="stat-card text-center" style={{ background: 'var(--kpi-teal-bg-solid)' }}>
                <p className="text-[10px] font-bold uppercase tracking-[0.1em]" style={{ color: 'var(--kpi-teal-text)' }}>Rounds Completed</p>
                <p className="text-3xl font-black mt-1.5 tabular-nums" style={{ color: 'var(--kpi-teal-text)' }}>{trainingStatus.rounds_completed}</p>
              </div>
              <div className="stat-card text-center" style={{ background: 'var(--kpi-green-bg-solid)' }}>
                <p className="text-[10px] font-bold uppercase tracking-[0.1em]" style={{ color: 'var(--kpi-green-text)' }}>Latest Accuracy</p>
                <p className="text-3xl font-black mt-1.5 tabular-nums" style={{ color: 'var(--kpi-green-text)' }}>
                  {trainingStatus.latest_metrics ? `${(trainingStatus.latest_metrics.accuracy * 100).toFixed(1)}%` : '—'}
                </p>
              </div>
              <div className="stat-card text-center" style={{ background: 'var(--kpi-blue-bg-solid)' }}>
                <p className="text-[10px] font-bold uppercase tracking-[0.1em]" style={{ color: 'var(--kpi-blue-text)' }}>Status</p>
                <div className="mt-3 flex justify-center">
                  <StatusBadge status={trainingStatus.is_training ? 'Training' : 'Ready'} />
                </div>
              </div>
            </div>
            <div className="info-banner mt-4" style={{ background: 'var(--status-info-bg-solid)', border: '1px solid var(--status-info-border)', color: 'var(--status-info)' }}>
              <svg className="w-4 h-4 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
              <span>The model is automatically trained when new patient data is uploaded.</span>
            </div>
          </Card>
        </motion.div>
      )}

      {/* How It Works */}
      <motion.div variants={staggerItem}>
        <Card>
          <div className="section-header mb-8">
            <div className="accent-bar" style={{ background: 'var(--brand-gradient-warm)' }} />
            <h3 className="text-sm font-bold" style={{ color: 'var(--text-primary)' }}>How It Works</h3>
          </div>
          <motion.div className="grid grid-cols-1 md:grid-cols-3 gap-8" variants={staggerContainer} initial="hidden" animate="visible">
            <WorkflowStep step={1} title="Upload Data" desc="Upload patient records in the Patients tab. Training starts automatically." color="#6366F1" icon={<svg className="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" /></svg>} />
            <WorkflowStep step={2} title="Browse Trials" desc="View drug trials with anonymized eligibility parameters from all hospitals." color="#0EA5E9" icon={<svg className="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" /></svg>} />
            <WorkflowStep step={3} title="Check Eligibility" desc="Click any trial to see which of your patients are eligible — data stays private." color="#10B981" icon={<svg className="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" /></svg>} />
          </motion.div>
        </Card>
      </motion.div>
    </motion.div>
  );
}



================================================================================
--- FILE: .\frontend\src\components\PatientsManager.jsx ---
================================================================================
import React, { useState, useEffect, useRef, useCallback, useMemo, memo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { apiService } from '../services/apiService';
import { Card, Button, TableSkeleton } from './ui';
import { useThemeStore } from '../stores/themeStore';
import { staggerItem } from '../utils/motionVariants';

/* ── helpers ─────────────────────────────────────────────────── */
const humanLabel = (key) => {
  const specials = { bmi: 'BMI', id: 'ID', dob: 'DOB' };
  return key.split('_').map((w) => specials[w] || w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
};

const renderCell = (value, key) => {
  if (value == null || value === '') return <span style={{ color: 'var(--text-tertiary)' }}>-</span>;
  if (Array.isArray(value)) return value.length ? value.join(', ') : <span style={{ color: 'var(--text-tertiary)' }}>None</span>;
  if (key === 'blood_group') return <span className="badge" style={{ background: 'var(--kpi-purple-bg)', color: 'var(--kpi-purple-text)', border: '1px solid var(--border-primary)' }}>{value}</span>;
  if (key === 'stage') return <span className="badge" style={{ background: 'var(--bg-tertiary)', color: 'var(--text-secondary)' }}>{value}</span>;
  if (key === 'gender') return <span className="badge" style={{ background: 'var(--kpi-purple-bg)', color: 'var(--kpi-purple-text)' }}>{value}</span>;
  if (key === 'phone') return <span className="font-mono text-xs" style={{ color: 'var(--brand-primary)' }}>{value}</span>;
  if (key === 'email') return <span className="text-xs underline truncate max-w-[180px] inline-block" style={{ color: 'var(--brand-primary)' }}>{value}</span>;
  if (key === 'address') return <span className="text-xs truncate max-w-[200px] inline-block" style={{ color: 'var(--text-secondary)' }} title={value}>{value}</span>;
  if (key === 'emergency_contact') return <span className="text-xs" style={{ color: 'var(--kpi-orange-text)' }}>{value}</span>;
  if (key === 'patient_name') return <span className="font-semibold" style={{ color: 'var(--text-primary)' }}>{value}</span>;
  if (key === 'hospital') return <span className="badge" style={{ background: 'var(--kpi-teal-bg)', color: 'var(--kpi-teal-text)' }}>{value}</span>;
  if (key === 'admission_date' || key === 'diagnosis_date') return <span className="text-xs font-mono" style={{ color: 'var(--text-secondary)' }}>{value}</span>;
  return String(value);
};

const PAGE_SIZE = 50;

/* ── component ───────────────────────────────────────────────── */
export default function PatientsManager({ user }) {
  const [patients, setPatients] = useState([]);
  const [columns, setColumns] = useState([]);
  const [loading, setLoading] = useState(false);
  const [uploadedFile, setUploadedFile] = useState(null);
  const [showUploadForm, setShowUploadForm] = useState(false);
  const [uploadStatus, setUploadStatus] = useState(null);
  const isDark = useThemeStore((s) => s.theme === 'dark');

  const [searchTerm, setSearchTerm] = useState('');
  const [debouncedSearch, setDebouncedSearch] = useState('');
  const [sortField, setSortField] = useState('patient_id');
  const [sortDir, setSortDir] = useState('asc');
  const [page, setPage] = useState(1);
  const [totalPatients, setTotalPatients] = useState(0);
  const [totalPages, setTotalPages] = useState(1);

  const [trainingMsg, setTrainingMsg] = useState(null);
  const [preprocessInfo, setPreprocessInfo] = useState(null);
  const [uploadProgress, setUploadProgress] = useState(null);
  const progressTimerRef = useRef(null);
  const searchTimerRef = useRef(null);

  const hospitalName = user?.hospital_name || '';

  useEffect(() => {
    if (searchTimerRef.current) clearTimeout(searchTimerRef.current);
    searchTimerRef.current = setTimeout(() => { setDebouncedSearch(searchTerm); setPage(1); }, 400);
    return () => clearTimeout(searchTimerRef.current);
  }, [searchTerm]);

  useEffect(() => { loadPatients(); }, [hospitalName, page, debouncedSearch, sortField, sortDir]);
  useEffect(() => () => { if (progressTimerRef.current) clearInterval(progressTimerRef.current); }, []);

  const loadPatients = async () => {
    try {
      setLoading(true);
      const response = await apiService.getPatients(hospitalName, { page, pageSize: PAGE_SIZE, search: debouncedSearch, sortBy: sortField, sortDir });
      setPatients(response.patients || []);
      setTotalPatients(response.total ?? 0);
      setTotalPages(response.total_pages ?? 1);
      if (response.columns?.length) setColumns(response.columns);
      else if (response.patients?.length) setColumns(Object.keys(response.patients[0]).filter(k => !['hospital','hospital_name','eligible','drug_worked'].includes(k)));
    } catch (error) { console.error('Error loading patients:', error); }
    finally { setLoading(false); }
  };

  const handleFileSelect = (e) => { const file = e.target.files[0]; if (file) { setUploadedFile(file); setUploadStatus(null); setPreprocessInfo(null); } };

  const startProgressPolling = useCallback((uploadId) => {
    if (progressTimerRef.current) clearInterval(progressTimerRef.current);
    setUploadProgress({ percent: 5, stage: 'Starting upload...' });
    progressTimerRef.current = setInterval(async () => {
      try { const prog = await apiService.getUploadProgress(uploadId); setUploadProgress(prog); if (prog.percent >= 100 || prog.percent < 0) { clearInterval(progressTimerRef.current); progressTimerRef.current = null; } } catch { /* ignore */ }
    }, 400);
  }, []);

  const handleUpload = async () => {
    if (!uploadedFile) { setUploadStatus({ type: 'error', message: 'Please select a file' }); return; }
    try {
      setLoading(true); setPreprocessInfo(null); setUploadProgress({ percent: 2, stage: 'Sending file to server...' });
      const onUploadProgress = (evt) => { if (evt.total) { const pct = Math.min(Math.round((evt.loaded / evt.total) * 10), 10); setUploadProgress({ percent: pct, stage: 'Uploading file...' }); } };
      const resultPromise = apiService.uploadFile(uploadedFile, hospitalName, onUploadProgress);
      let simPercent = 10;
      const stages = ['Parsing file...','Detecting columns...','Normalising data...','Generating patient IDs...','Saving standard CSV...','Merging into store...','Persisting JSON...','Generating training CSV...','Logging to blockchain...'];
      const simTimer = setInterval(() => { if (simPercent < 90) { simPercent += Math.random() * 12 + 3; if (simPercent > 90) simPercent = 90; const stageIdx = Math.min(Math.floor((simPercent - 10) / 10), stages.length - 1); setUploadProgress({ percent: Math.round(simPercent), stage: stages[stageIdx] }); } }, 600);
      const result = await resultPromise;
      clearInterval(simTimer);
      setUploadProgress({ percent: 100, stage: 'Complete!' });
      setUploadStatus({ type: 'success', message: result.message });
      setPreprocessInfo({ fileType: (result.file_type || '').toUpperCase(), newPatients: result.new_patients || 0, hospitals: result.hospitals_in_file || [], totalPatients: result.total_patients || 0 });
      if (result.columns?.length) setColumns(result.columns);
      setUploadedFile(null); setPage(0); setTimeout(() => { setPage(1); }, 50);
      try { setTrainingMsg({ type: 'info', message: 'Preprocessing complete. Starting federated model training...' }); await apiService.startTraining({ num_rounds: 10 }); setTrainingMsg({ type: 'success', message: 'Model training started automatically.' }); setTimeout(() => setTrainingMsg(null), 6000); } catch (trainErr) { const msg = trainErr?.response?.data?.detail || 'Training could not be started'; setTrainingMsg({ type: 'warning', message: msg }); setTimeout(() => setTrainingMsg(null), 4000); }
      setTimeout(() => { setShowUploadForm(false); setPreprocessInfo(null); setUploadProgress(null); }, 5000);
    } catch (error) {
      if (progressTimerRef.current) clearInterval(progressTimerRef.current);
      setUploadProgress(null);
      setUploadStatus({ type: 'error', message: error?.response?.data?.detail || error.message });
    } finally { setLoading(false); }
  };

  const handleSort = (field) => { if (sortField === field) setSortDir(d => d === 'asc' ? 'desc' : 'asc'); else { setSortField(field); setSortDir('asc'); } setPage(1); };

  const SortIcon = ({ field }) => (
    <span className="ml-1" style={{ color: 'var(--text-tertiary)' }}>
      {sortField === field ? (sortDir === 'asc' ? '▲' : '▼') : '⇅'}
    </span>
  );

  const pageNumbers = useMemo(() => {
    const pages = []; const maxVisible = 7;
    if (totalPages <= maxVisible) { for (let i = 1; i <= totalPages; i++) pages.push(i); }
    else { pages.push(1); let start = Math.max(2, page - 2), end = Math.min(totalPages - 1, page + 2); if (start > 2) pages.push('...'); for (let i = start; i <= end; i++) pages.push(i); if (end < totalPages - 1) pages.push('...'); pages.push(totalPages); }
    return pages;
  }, [page, totalPages]);

  /* ── progress bar ───────────────────────────────────────────── */
  const ProgressBar = () => {
    if (!uploadProgress) return null;
    const pct = Math.max(0, Math.min(uploadProgress.percent, 100));
    const isError = pct < 0, isDone = pct >= 100;
    const barColor = isError ? 'var(--status-error)' : isDone ? 'var(--status-success)' : 'var(--brand-primary)';
    const bgToken = isError ? 'error' : isDone ? 'success' : 'info';
    return (
      <div className="p-4 rounded-lg mb-4" style={{ background: `var(--status-${bgToken}-bg)`, border: `1px solid var(--status-${bgToken}-border)` }}>
        <div className="flex justify-between items-center mb-2">
          <span className="text-sm font-semibold" style={{ color: barColor }}>{uploadProgress.stage}</span>
          <span className="text-sm font-bold" style={{ color: barColor }}>{isDone ? '100%' : isError ? 'Error' : `${pct}%`}</span>
        </div>
        <div className="w-full rounded-full h-2.5 overflow-hidden" style={{ background: 'var(--bg-tertiary)' }}>
          <motion.div className="h-full rounded-full" style={{ background: barColor }} animate={{ width: `${Math.max(pct, 0)}%` }} transition={{ duration: 0.5, ease: 'easeOut' }} />
        </div>
        {!isDone && !isError && (
          <div className="flex items-center gap-2 mt-2">
            <div className="animate-spin rounded-full h-3.5 w-3.5" style={{ borderBottom: `2px solid var(--brand-primary)`, borderRight: '2px solid transparent' }} />
            <span className="text-xs" style={{ color: 'var(--brand-primary)' }}>Processing...</span>
          </div>
        )}
        {isDone && (
          <div className="flex items-center gap-2 mt-2">
            <svg className="w-4 h-4" style={{ color: 'var(--status-success)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" /></svg>
            <span className="text-xs font-medium" style={{ color: 'var(--status-success)' }}>Preprocessing complete — patients loaded!</span>
          </div>
        )}
      </div>
    );
  };

  /* ── render ─────────────────────────────────────────────────── */
  return (
    <motion.div variants={staggerItem} initial="hidden" animate="visible">
      <Card padding="p-6">
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6">
          <div>
            <div className="flex items-center gap-2">
              <div className="w-1.5 h-6 rounded-full" style={{ background: 'var(--brand-primary)' }} />
              <h2 className="text-xl font-bold" style={{ color: 'var(--text-primary)' }}>My Patients</h2>
            </div>
            <p className="text-xs mt-1.5 ml-3.5" style={{ color: 'var(--text-tertiary)' }}>
              Showing patients from <span className="font-semibold" style={{ color: 'var(--brand-primary)' }}>{hospitalName}</span>
            </p>
          </div>
          <Button variant="primary" onClick={() => setShowUploadForm(!showUploadForm)} icon={<svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>}>
            Upload Data
          </Button>
        </div>

        {trainingMsg && (
          <motion.div
            className="mb-4 p-3 rounded-lg text-sm flex items-start gap-2"
            style={{
              background: trainingMsg.type === 'success' ? 'var(--status-success-bg)' : trainingMsg.type === 'info' ? 'var(--status-info-bg)' : 'var(--status-warning-bg)',
              border: `1px solid ${trainingMsg.type === 'success' ? 'var(--status-success-border)' : trainingMsg.type === 'info' ? 'var(--status-info-border)' : 'var(--status-warning-border)'}`,
              color: trainingMsg.type === 'success' ? 'var(--status-success)' : trainingMsg.type === 'info' ? 'var(--status-info)' : 'var(--status-warning)',
            }}
            initial={{ opacity: 0, y: -4 }} animate={{ opacity: 1, y: 0 }}
          >
            <svg className="w-5 h-5 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>
            <span>{trainingMsg.message}</span>
          </motion.div>
        )}

        <div className="mb-4 p-3 rounded-lg text-sm flex items-start gap-2" style={{ background: 'var(--status-success-bg)', border: '1px solid var(--status-success-border)', color: 'var(--status-success)' }}>
          <svg className="w-5 h-5 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" /></svg>
          <span><strong>Full Patient Records:</strong> All personal &amp; medical details are visible because this is your hospital's own data. This information is never shared with other hospitals or external systems.</span>
        </div>

        {/* Upload Form */}
        <AnimatePresence>
          {showUploadForm && (
            <motion.div
              className="mb-6 p-4 rounded-lg"
              style={{ background: 'var(--bg-tertiary)', border: '1px solid var(--border-primary)' }}
              initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }}
              transition={{ duration: 0.3, ease: [0.4, 0, 0.2, 1] }}
            >
              <h3 className="text-lg font-semibold mb-4" style={{ color: 'var(--text-primary)' }}>Upload Patient Data</h3>
              <div className="space-y-4">
                <label className="w-full flex flex-col items-center justify-center px-4 py-6 rounded-lg cursor-pointer" style={{ background: 'var(--bg-card)', border: '2px dashed var(--brand-primary)', color: 'var(--brand-primary)' }}>
                  <svg className="w-8 h-8" fill="currentColor" viewBox="0 0 20 20"><path d="M16.88 9.1A4 4 0 0 1 16 17H4a5 5 0 0 1-1-9.9V7a3 3 0 0 1 6-3h2a3 3 0 0 1 2 .9l5.07 5.07a1 1 0 1 1-1.42 1.42L12.07 7H10" /></svg>
                  <span className="mt-2 text-base">{uploadedFile ? uploadedFile.name : 'Select CSV, JSON, or PDF file'}</span>
                  <input type="file" className="hidden" accept=".csv,.json,.pdf" onChange={handleFileSelect} />
                </label>
                <ProgressBar />
                {uploadStatus && (
                  <div className="p-4 rounded-lg" style={{
                    background: uploadStatus.type === 'success' ? 'var(--status-success-bg)' : 'var(--status-error-bg)',
                    border: `1px solid ${uploadStatus.type === 'success' ? 'var(--status-success-border)' : 'var(--status-error-border)'}`,
                    color: uploadStatus.type === 'success' ? 'var(--status-success)' : 'var(--status-error)',
                  }}>{uploadStatus.message}</div>
                )}
                {preprocessInfo && (
                  <div className="p-4 rounded-lg text-sm" style={{ background: 'var(--kpi-purple-bg)', border: '1px solid var(--border-primary)', color: 'var(--kpi-purple-text)' }}>
                    <p className="font-semibold mb-1">Preprocessing Summary</p>
                    <div className="grid grid-cols-2 gap-2 text-xs">
                      <span>File type: <strong>{preprocessInfo.fileType}</strong></span>
                      <span>New patients: <strong>{preprocessInfo.newPatients}</strong></span>
                      <span>Hospitals: <strong>{preprocessInfo.hospitals.join(', ')}</strong></span>
                      <span>Total in store: <strong>{preprocessInfo.totalPatients}</strong></span>
                    </div>
                  </div>
                )}
                <div className="flex gap-2">
                  <Button variant="primary" className="flex-1" onClick={handleUpload} disabled={!uploadedFile || loading} loading={loading}>Upload &amp; Preprocess</Button>
                  <Button variant="secondary" className="flex-1" onClick={() => { setShowUploadForm(false); setUploadProgress(null); }}>Cancel</Button>
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Search */}
        <div className="mb-4">
          <input type="text" placeholder="Search across all fields..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="input" />
        </div>

        {/* Stats */}
        <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 mb-4">
          {[
            { label: 'Total Patients', value: totalPatients.toLocaleString(), bg: 'var(--kpi-blue-bg)', color: 'var(--kpi-blue-text)' },
            { label: 'Showing', value: patients.length, bg: 'var(--kpi-purple-bg)', color: 'var(--kpi-purple-text)' },
            { label: 'Page', value: `${page} / ${totalPages}`, bg: 'var(--kpi-teal-bg)', color: 'var(--kpi-teal-text)' },
            { label: 'Per Page', value: PAGE_SIZE, bg: 'var(--kpi-orange-bg)', color: 'var(--kpi-orange-text)' },
          ].map((s) => (
            <div key={s.label} className="rounded-xl p-3 text-center" style={{ background: s.bg }}>
              <p className="text-[10px] font-semibold uppercase tracking-wider" style={{ color: s.color }}>{s.label}</p>
              <p className="text-xl font-extrabold tabular-nums mt-0.5" style={{ color: s.color }}>{s.value}</p>
            </div>
          ))}
        </div>

        {/* Column badges */}
        {columns.length > 0 && (
          <div className="mb-3 flex items-center gap-2 flex-wrap">
            <span className="text-xs font-medium" style={{ color: 'var(--text-tertiary)' }}>Columns:</span>
            {columns.map(col => (
              <span key={col} className="badge" style={{ background: 'var(--bg-tertiary)', color: 'var(--text-secondary)', border: '1px solid var(--border-primary)' }}>{humanLabel(col)}</span>
            ))}
          </div>
        )}

        {/* Table */}
        {loading && !showUploadForm ? (
          <TableSkeleton cols={columns.length || 6} rows={8} />
        ) : (
          <>
            <div className="overflow-x-auto" style={{ border: '1px solid var(--table-border)', borderRadius: 'var(--radius-md)' }}>
                <table className="w-full text-sm themed-table">
                  <thead>
                    <tr>
                      {columns.map(col => (
                        <th key={col} onClick={() => handleSort(col)} className="px-4 py-3 text-left cursor-pointer select-none whitespace-nowrap" style={{ background: 'var(--table-header-bg)' }}>
                          {humanLabel(col)}<SortIcon field={col} />
                        </th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {patients.length === 0 ? (
                      <tr><td colSpan={columns.length || 1} className="px-6 py-8 text-center" style={{ color: 'var(--text-tertiary)' }}>{debouncedSearch ? 'No patients match your search.' : 'No patients found. Upload a file to get started.'}</td></tr>
                    ) : patients.map((patient, idx) => (
                      <tr key={patient.patient_id || idx}>
                        {columns.map(col => (
                          <td key={col} className="px-4 py-3 whitespace-nowrap" style={{ color: 'var(--text-primary)' }}>
                            {col === 'patient_id' ? <span className="font-medium">{patient[col]}</span> : renderCell(patient[col], col)}
                          </td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>

            </div>

            {/* Pagination */}
            {totalPages > 1 && (
              <div className="flex items-center justify-between mt-4">
                <Button variant="secondary" size="sm" onClick={() => setPage(p => Math.max(1, p - 1))} disabled={page <= 1}>← Previous</Button>
                <div className="flex items-center gap-1">
                  {pageNumbers.map((p, i) =>
                    p === '...' ? <span key={`dots-${i}`} className="px-2 py-1" style={{ color: 'var(--text-tertiary)' }}>...</span> : (
                      <button key={p} onClick={() => setPage(p)} className="btn text-sm" style={{
                        background: p === page ? 'var(--brand-primary)' : 'var(--bg-card)',
                        color: p === page ? '#fff' : 'var(--text-primary)',
                        border: `1px solid ${p === page ? 'var(--brand-primary)' : 'var(--border-primary)'}`,
                        padding: '0.35rem 0.75rem',
                      }}>{p}</button>
                    )
                  )}
                </div>
                <Button variant="secondary" size="sm" onClick={() => setPage(p => Math.min(totalPages, p + 1))} disabled={page >= totalPages}>Next →</Button>
              </div>
            )}

            <div className="text-center py-2 text-xs mt-2" style={{ color: 'var(--text-tertiary)' }}>
              Showing {((page - 1) * PAGE_SIZE) + 1}–{Math.min(page * PAGE_SIZE, totalPatients)} of {totalPatients.toLocaleString()} patients
            </div>
          </>
        )}
      </Card>
    </motion.div>
  );
}


================================================================================
--- FILE: .\frontend\src\components\TrialsViewer.jsx ---
================================================================================
import React, { useState, useEffect, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { apiService } from '../services/apiService';
import { Card, Button, StatusBadge, TableSkeleton, CardSkeleton } from './ui';
import { useThemeStore } from '../stores/themeStore';
import { staggerContainer, staggerItem, fadeIn, slideUp } from '../utils/motionVariants';

/* helper: snake_case → Title Case */
const humanLabel = (key) => {
  const specials = { bmi: 'BMI', id: 'ID', dob: 'DOB' };
  return key.split('_').map((w) => specials[w] || w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
};
const renderCell = (value, key) => {
  if (value == null || value === '') return <span style={{ color: 'var(--text-tertiary)' }}>-</span>;
  if (Array.isArray(value)) return value.length ? value.join(', ') : <span style={{ color: 'var(--text-tertiary)' }}>None</span>;
  if (key === 'blood_group') return <span className="badge" style={{ background: 'var(--kpi-purple-bg)', color: 'var(--kpi-purple-text)' }}>{value}</span>;
  if (key === 'stage') return <span className="badge" style={{ background: 'var(--bg-tertiary)', color: 'var(--text-secondary)' }}>{value}</span>;
  if (key === 'patient_id' && String(value).startsWith('ANON-')) return <span className="badge font-mono" style={{ background: 'var(--kpi-orange-bg)', color: 'var(--kpi-orange-text)' }}>{value}</span>;
  return String(value);
};

const PAGE_SIZE = 50;

export default function TrialsViewer({ user }) {
  const [trials, setTrials] = useState([]);
  const [loading, setLoading] = useState(false);
  const [selectedTrial, setSelectedTrial] = useState(null);

  const [eligData, setEligData] = useState(null);
  const [eligLoading, setEligLoading] = useState(false);
  const [activeTab, setActiveTab] = useState('eligible');
  const [eligPage, setEligPage] = useState(1);

  const [searchTerm, setSearchTerm] = useState('');
  const [showBreakdown, setShowBreakdown] = useState(null); // 'eligible' | 'not_eligible' | null
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [newTrial, setNewTrial] = useState({ drugName: '', indication: '', phase: 'Phase III', status: 'Active', successRate: '' });
  const [createError, setCreateError] = useState('');
  const [creating, setCreating] = useState(false);
  const hospitalName = user?.hospital_name || '';
  const isDark = useThemeStore((s) => s.theme === 'dark');

  useEffect(() => { loadTrials(); }, []);

  const loadTrials = async () => {
    try { setLoading(true); const response = await apiService.getTrials(hospitalName); setTrials(response.trials || []); }
    catch (error) { console.error('Error loading trials:', error); }
    finally { setLoading(false); }
  };

  const loadEligibility = async (drugName, tab, page) => {
    try { setEligLoading(true); const data = await apiService.getEligibleForDrug(drugName, hospitalName, { page, pageSize: PAGE_SIZE, tab }); setEligData(data); }
    catch (error) { console.error('Error fetching eligibility:', error); }
    finally { setEligLoading(false); }
  };

  const handleSelectTrial = (trial) => { setSelectedTrial(trial); setEligData(null); setActiveTab('eligible'); setEligPage(1); setShowBreakdown(null); loadEligibility(trial.drugName, 'eligible', 1); };
  useEffect(() => { if (selectedTrial) loadEligibility(selectedTrial.drugName, activeTab, eligPage); }, [activeTab, eligPage]);
  const handleTabChange = (tab) => { setActiveTab(tab); setEligPage(1); };

  const filtered = trials.filter(t => {
    const term = searchTerm.toLowerCase();
    return !term || t.drugName.toLowerCase().includes(term) || t.indication.toLowerCase().includes(term);
  });

  const handleBack = () => { setSelectedTrial(null); setEligData(null); };

  const handleCreateTrial = async (e) => {
    e.preventDefault();
    setCreateError('');
    if (!newTrial.drugName.trim() || !newTrial.indication.trim()) {
      setCreateError('Drug name and indication are required');
      return;
    }
    try {
      setCreating(true);
      const payload = {
        drugName: newTrial.drugName.trim(),
        indication: newTrial.indication.trim(),
        phase: newTrial.phase,
        status: newTrial.status,
        successRate: parseFloat(newTrial.successRate) || 0,
      };
      await apiService.createTrial(payload, hospitalName);
      setShowCreateModal(false);
      setNewTrial({ drugName: '', indication: '', phase: 'Phase III', status: 'Active', successRate: '' });
      await loadTrials();
    } catch (error) {
      const msg = error?.response?.data?.detail || error.message || 'Failed to create trial';
      setCreateError(msg);
    } finally {
      setCreating(false);
    }
  };

  const pageNumbers = useMemo(() => {
    if (!eligData) return [];
    const tp = eligData.total_pages || 1, cp = eligData.page || 1, pages = [], maxVisible = 7;
    if (tp <= maxVisible) { for (let i = 1; i <= tp; i++) pages.push(i); }
    else { pages.push(1); let start = Math.max(2, cp - 2), end = Math.min(tp - 1, cp + 2); if (start > 2) pages.push('...'); for (let i = start; i <= end; i++) pages.push(i); if (end < tp - 1) pages.push('...'); pages.push(tp); }
    return pages;
  }, [eligData]);

  /* === DETAIL VIEW === */
  if (selectedTrial) {
    const columns = eligData?.columns || [];
    const patients = eligData?.patients || [];
    const eligibleCount = eligData?.eligible_count ?? 0;
    const notEligibleCount = eligData?.not_eligible_count ?? 0;
    const hospitalEligible = eligData?.hospital_eligible_count ?? 0;
    const hospitalNotEligible = eligData?.hospital_not_eligible_count ?? 0;
    const hospitalTotal = eligData?.hospital_total ?? 0;
    const hospitalBreakdown = eligData?.hospital_breakdown ?? {};
    const totalPages = eligData?.total_pages ?? 1;
    const currentPage = eligData?.page ?? 1;

    const isElig = activeTab === 'eligible';
    const tabAccent = isElig ? 'var(--status-success)' : 'var(--status-error)';
    const tabAccentBg = isElig ? 'var(--status-success-bg)' : 'var(--status-error-bg)';
    const tabAccentBorder = isElig ? 'var(--status-success-border)' : 'var(--status-error-border)';

    return (
      <motion.div className="space-y-6" variants={fadeIn} initial="hidden" animate="visible">
        <button onClick={handleBack} className="inline-flex items-center gap-2 font-medium transition hover:opacity-80" style={{ color: 'var(--brand-primary)' }}>
          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" /></svg>
          Back to All Trials
        </button>

        <Card className="border-t-4" style={{ borderTopColor: 'var(--brand-primary)' }}>
          <div className="mb-4">
            <div className="flex items-center gap-2">
              <div className="w-1.5 h-6 rounded-full" style={{ background: 'var(--brand-primary)' }} />
              <h2 className="text-xl font-bold" style={{ color: 'var(--text-primary)' }}>{selectedTrial.drugName}</h2>
            </div>
            <p className="text-xs mt-1.5 ml-3.5" style={{ color: 'var(--text-tertiary)' }}>Eligibility check across all federated hospitals — your hospital's results highlighted below</p>
          </div>

          {/* Privacy banner */}
          <div className="mb-4 p-3 rounded-lg text-sm flex items-start gap-2" style={{ background: 'var(--status-warning-bg)', border: '1px solid var(--status-warning-border)', color: 'var(--status-warning)' }}>
            <svg className="w-5 h-5 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" /></svg>
            <div><strong>Privacy-Preserving Mode:</strong> Personal details (name, phone, email, address) are <strong>hidden</strong> in trial screening. Only anonymized IDs and medical/demographic data are shown to protect patient privacy across federated hospitals.</div>
          </div>

          {/* Trial summary KPIs */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mb-6">
            {[
              { label: 'Disease', value: selectedTrial.indication, bg: 'var(--bg-tertiary)' },
              { label: 'Phase / Status', value: `${selectedTrial.phase} / ${selectedTrial.status}`, bg: 'var(--bg-tertiary)' },
              { label: 'Global Success Rate', value: `${selectedTrial.successRate}%`, color: 'var(--status-success)' },
              { label: 'Enrolled', value: selectedTrial.patientsEnrolled, color: 'var(--brand-primary)' },
            ].map(kpi => (
              <div key={kpi.label} className="rounded-lg p-3" style={{ background: kpi.bg || 'var(--bg-tertiary)', border: '1px solid var(--border-primary)' }}>
                <p className="text-xs" style={{ color: 'var(--text-tertiary)' }}>{kpi.label}</p>
                <p className="text-sm font-semibold" style={{ color: kpi.color || 'var(--text-primary)' }}>{kpi.value}</p>
              </div>
            ))}
          </div>

          {/* Summary counts — Hospital-specific + Global */}
          {hospitalTotal > 0 && (
            <>
              <div className="mb-2">
                <p className="text-xs font-bold uppercase tracking-wider mb-2 ml-1" style={{ color: 'var(--brand-primary)' }}>Your Hospital ({hospitalName}) — {hospitalTotal.toLocaleString()} patients</p>
                <div className="grid grid-cols-2 gap-3">
                  <div className="rounded-xl p-4 text-center" style={{ background: 'var(--status-success-bg)', border: '2px solid var(--status-success)' }}>
                    <p className="text-3xl font-extrabold tabular-nums" style={{ color: 'var(--status-success)' }}>{hospitalEligible.toLocaleString()}</p>
                    <p className="text-[11px] font-semibold uppercase tracking-wider mt-1" style={{ color: 'var(--status-success)' }}>Eligible from Your Hospital</p>
                  </div>
                  <div className="rounded-xl p-4 text-center" style={{ background: 'var(--status-error-bg)', border: '2px solid var(--status-error)' }}>
                    <p className="text-3xl font-extrabold tabular-nums" style={{ color: 'var(--status-error)' }}>{hospitalNotEligible.toLocaleString()}</p>
                    <p className="text-[11px] font-semibold uppercase tracking-wider mt-1" style={{ color: 'var(--status-error)' }}>Not Eligible from Your Hospital</p>
                  </div>
                </div>
              </div>
              <div className="mb-4">
                <p className="text-xs font-bold uppercase tracking-wider mb-2 ml-1" style={{ color: 'var(--text-tertiary)' }}>Global Federated Pool — {(eligibleCount + notEligibleCount).toLocaleString()} patients across all hospitals</p>
                <div className="grid grid-cols-2 gap-3">
                  <button onClick={() => setShowBreakdown(showBreakdown === 'eligible' ? null : 'eligible')} className="rounded-xl p-3 text-center cursor-pointer transition-all duration-200 hover:scale-[1.02]" style={{ background: showBreakdown === 'eligible' ? 'var(--status-success-bg)' : 'var(--bg-tertiary)', border: `2px solid ${showBreakdown === 'eligible' ? 'var(--status-success)' : 'var(--status-success-border)'}` }}>
                    <p className="text-xl font-bold tabular-nums" style={{ color: 'var(--status-success)' }}>{eligibleCount.toLocaleString()}</p>
                    <p className="text-[10px] font-semibold uppercase tracking-wider mt-1" style={{ color: 'var(--text-tertiary)' }}>Eligible (All Hospitals)</p>
                  </button>
                  <button onClick={() => setShowBreakdown(showBreakdown === 'not_eligible' ? null : 'not_eligible')} className="rounded-xl p-3 text-center cursor-pointer transition-all duration-200 hover:scale-[1.02]" style={{ background: showBreakdown === 'not_eligible' ? 'var(--status-error-bg)' : 'var(--bg-tertiary)', border: `2px solid ${showBreakdown === 'not_eligible' ? 'var(--status-error)' : 'var(--status-error-border)'}` }}>
                    <p className="text-xl font-bold tabular-nums" style={{ color: 'var(--status-error)' }}>{notEligibleCount.toLocaleString()}</p>
                    <p className="text-[10px] font-semibold uppercase tracking-wider mt-1" style={{ color: 'var(--text-tertiary)' }}>Not Eligible (All Hospitals)</p>
                  </button>
                </div>
                {showBreakdown && (
                  <motion.div initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }} className="mt-3 rounded-xl overflow-hidden" style={{ border: `1px solid ${showBreakdown === 'eligible' ? 'var(--status-success-border)' : 'var(--status-error-border)'}` }}>
                    <table className="w-full text-sm">
                      <thead>
                        <tr style={{ background: showBreakdown === 'eligible' ? 'var(--status-success-bg)' : 'var(--status-error-bg)' }}>
                          <th className="px-4 py-2.5 text-left text-xs font-semibold uppercase tracking-wider" style={{ color: showBreakdown === 'eligible' ? 'var(--status-success)' : 'var(--status-error)' }}>Hospital</th>
                          <th className="px-4 py-2.5 text-right text-xs font-semibold uppercase tracking-wider" style={{ color: showBreakdown === 'eligible' ? 'var(--status-success)' : 'var(--status-error)' }}>{showBreakdown === 'eligible' ? 'Eligible' : 'Not Eligible'} Patients</th>
                        </tr>
                      </thead>
                      <tbody>
                        {Object.entries(hospitalBreakdown).filter(([, c]) => (showBreakdown === 'eligible' ? c.eligible > 0 : c.not_eligible > 0)).sort((a, b) => (showBreakdown === 'eligible' ? b[1].eligible - a[1].eligible : b[1].not_eligible - a[1].not_eligible)).map(([hName, counts]) => (
                          <tr key={hName} style={{ borderTop: '1px solid var(--border-primary)' }}>
                            <td className="px-4 py-2.5 font-medium" style={{ color: 'var(--text-primary)' }}>{hName}</td>
                            <td className="px-4 py-2.5 text-right font-bold tabular-nums" style={{ color: showBreakdown === 'eligible' ? 'var(--status-success)' : 'var(--status-error)' }}>{showBreakdown === 'eligible' ? counts.eligible.toLocaleString() : counts.not_eligible.toLocaleString()}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </motion.div>
                )}
              </div>
            </>
          )}
          {hospitalTotal === 0 && (
            <div className="mb-4">
              <div className="grid grid-cols-2 gap-3">
                <button onClick={() => setShowBreakdown(showBreakdown === 'eligible' ? null : 'eligible')} className="rounded-xl p-4 text-center cursor-pointer transition-all duration-200 hover:scale-[1.02]" style={{ background: showBreakdown === 'eligible' ? 'var(--status-success-bg)' : 'var(--status-success-bg)', border: `2px solid ${showBreakdown === 'eligible' ? 'var(--status-success)' : 'var(--status-success-border)'}` }}>
                  <p className="text-3xl font-extrabold tabular-nums" style={{ color: 'var(--status-success)' }}>{eligibleCount.toLocaleString()}</p>
                  <p className="text-[11px] font-semibold uppercase tracking-wider mt-1" style={{ color: 'var(--status-success)' }}>Eligible Patients</p>
                </button>
                <button onClick={() => setShowBreakdown(showBreakdown === 'not_eligible' ? null : 'not_eligible')} className="rounded-xl p-4 text-center cursor-pointer transition-all duration-200 hover:scale-[1.02]" style={{ background: showBreakdown === 'not_eligible' ? 'var(--status-error-bg)' : 'var(--status-error-bg)', border: `2px solid ${showBreakdown === 'not_eligible' ? 'var(--status-error)' : 'var(--status-error-border)'}` }}>
                  <p className="text-3xl font-extrabold tabular-nums" style={{ color: 'var(--status-error)' }}>{notEligibleCount.toLocaleString()}</p>
                  <p className="text-[11px] font-semibold uppercase tracking-wider mt-1" style={{ color: 'var(--status-error)' }}>Not Eligible</p>
                </button>
              </div>
              {showBreakdown && (
                <motion.div initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }} className="mt-3 rounded-xl overflow-hidden" style={{ border: `1px solid ${showBreakdown === 'eligible' ? 'var(--status-success-border)' : 'var(--status-error-border)'}` }}>
                  <table className="w-full text-sm">
                    <thead>
                      <tr style={{ background: showBreakdown === 'eligible' ? 'var(--status-success-bg)' : 'var(--status-error-bg)' }}>
                        <th className="px-4 py-2.5 text-left text-xs font-semibold uppercase tracking-wider" style={{ color: showBreakdown === 'eligible' ? 'var(--status-success)' : 'var(--status-error)' }}>Hospital</th>
                        <th className="px-4 py-2.5 text-right text-xs font-semibold uppercase tracking-wider" style={{ color: showBreakdown === 'eligible' ? 'var(--status-success)' : 'var(--status-error)' }}>{showBreakdown === 'eligible' ? 'Eligible' : 'Not Eligible'} Patients</th>
                      </tr>
                    </thead>
                    <tbody>
                      {Object.entries(hospitalBreakdown).filter(([, c]) => (showBreakdown === 'eligible' ? c.eligible > 0 : c.not_eligible > 0)).sort((a, b) => (showBreakdown === 'eligible' ? b[1].eligible - a[1].eligible : b[1].not_eligible - a[1].not_eligible)).map(([hName, counts]) => (
                        <tr key={hName} style={{ borderTop: '1px solid var(--border-primary)' }}>
                          <td className="px-4 py-2.5 font-medium" style={{ color: 'var(--text-primary)' }}>{hName}</td>
                          <td className="px-4 py-2.5 text-right font-bold tabular-nums" style={{ color: showBreakdown === 'eligible' ? 'var(--status-success)' : 'var(--status-error)' }}>{showBreakdown === 'eligible' ? counts.eligible.toLocaleString() : counts.not_eligible.toLocaleString()}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </motion.div>
              )}
            </div>
          )}

          {/* Tab buttons */}
          <div className="flex gap-2 mb-4">
            <button onClick={() => handleTabChange('eligible')} className="flex-1 py-2 px-4 rounded-lg font-semibold text-sm transition" style={{
              background: activeTab === 'eligible' ? 'var(--status-success)' : 'var(--bg-tertiary)',
              color: activeTab === 'eligible' ? '#fff' : 'var(--text-secondary)',
              border: `1px solid ${activeTab === 'eligible' ? 'var(--status-success)' : 'var(--border-primary)'}`,
            }}>Eligible ({eligibleCount.toLocaleString()})</button>
            <button onClick={() => handleTabChange('not_eligible')} className="flex-1 py-2 px-4 rounded-lg font-semibold text-sm transition" style={{
              background: activeTab === 'not_eligible' ? 'var(--status-error)' : 'var(--bg-tertiary)',
              color: activeTab === 'not_eligible' ? '#fff' : 'var(--text-secondary)',
              border: `1px solid ${activeTab === 'not_eligible' ? 'var(--status-error)' : 'var(--border-primary)'}`,
            }}>Not Eligible ({notEligibleCount.toLocaleString()})</button>
          </div>

          {/* Paginated table */}
          {eligLoading ? (
            <TableSkeleton cols={columns.length || 6} rows={6} />
          ) : patients.length > 0 ? (
            <>
              <div className="overflow-x-auto rounded-lg" style={{ border: `1px solid ${tabAccentBorder}` }}>
                  <table className="w-full text-sm themed-table">
                    <thead>
                      <tr>
                        <th className="px-3 py-2 text-left text-xs font-semibold" style={{ background: tabAccentBg, color: tabAccent }}>#</th>
                        {columns.map(col => <th key={col} className="px-3 py-2 text-left text-xs font-semibold whitespace-nowrap" style={{ background: tabAccentBg, color: tabAccent }}>{humanLabel(col)}</th>)}
                      </tr>
                    </thead>
                    <tbody>
                      {patients.map((p, i) => (
                        <tr key={p.patient_id || i}>
                          <td className="px-3 py-2" style={{ color: 'var(--text-tertiary)' }}>{(currentPage - 1) * PAGE_SIZE + i + 1}</td>
                          {columns.map(col => <td key={col} className="px-3 py-2 whitespace-nowrap" style={{ color: 'var(--text-primary)' }}>{col === 'patient_id' ? <span className="font-medium">{p[col]}</span> : renderCell(p[col], col)}</td>)}
                        </tr>
                      ))}
                    </tbody>
                  </table>
              </div>

              {/* Pagination */}
              {totalPages > 1 && (
                <div className="flex items-center justify-between mt-4">
                  <Button variant="secondary" size="sm" onClick={() => setEligPage(p => Math.max(1, p - 1))} disabled={currentPage <= 1}>← Previous</Button>
                  <div className="flex items-center gap-1">
                    {pageNumbers.map((p, i) =>
                      p === '...' ? <span key={`d${i}`} className="px-2 py-1" style={{ color: 'var(--text-tertiary)' }}>...</span> : (
                        <button key={p} onClick={() => setEligPage(p)} className="btn text-sm" style={{
                          background: p === currentPage ? 'var(--brand-primary)' : 'var(--bg-card)',
                          color: p === currentPage ? '#fff' : 'var(--text-primary)',
                          border: `1px solid ${p === currentPage ? 'var(--brand-primary)' : 'var(--border-primary)'}`,
                          padding: '0.35rem 0.75rem',
                        }}>{p}</button>
                      )
                    )}
                  </div>
                  <Button variant="secondary" size="sm" onClick={() => setEligPage(p => Math.min(totalPages, p + 1))} disabled={currentPage >= totalPages}>Next →</Button>
                </div>
              )}
              <div className="text-center py-2 text-xs mt-1" style={{ color: 'var(--text-tertiary)' }}>
                Showing {(currentPage - 1) * PAGE_SIZE + 1}–{Math.min(currentPage * PAGE_SIZE, isElig ? eligibleCount : notEligibleCount)} of {(isElig ? eligibleCount : notEligibleCount).toLocaleString()} patients
              </div>
            </>
          ) : (
            <div className="text-center py-6" style={{ color: 'var(--text-tertiary)' }}>No {isElig ? 'eligible' : 'ineligible'} patients found.</div>
          )}
        </Card>

        {/* Privacy footer */}
        <div className="p-3 rounded-lg text-sm flex items-start gap-2" style={{ background: 'var(--status-info-bg)', border: '1px solid var(--status-info-border)', color: 'var(--status-info)' }}>
          <svg className="w-5 h-5 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
          <span><strong>Federated Privacy:</strong> Patient identities are anonymized (ANON-XXXXX). Only age, gender, blood group, disease, stage, BMI, and comorbidities are shared for eligibility screening. No personal information leaves your hospital.</span>
        </div>
      </motion.div>
    );
  }

  /* === LIST VIEW === */
  return (
    <motion.div className="space-y-6" variants={fadeIn} initial="hidden" animate="visible">
      <Card>
        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-4">
          <div>
            <div className="flex items-center gap-2 mb-4">
              <div className="w-1.5 h-6 rounded-full" style={{ background: 'var(--brand-primary)' }} />
              <h2 className="text-xl font-bold" style={{ color: 'var(--text-primary)' }}>Clinical Trials</h2>
            </div>
            <p className="text-xs ml-3.5" style={{ color: 'var(--text-tertiary)' }}>Click a trial to see how many current patients are eligible</p>
          </div>
          <div className="flex gap-2">
            <Button variant="secondary" onClick={loadTrials}>Refresh</Button>
            <Button variant="primary" onClick={() => { setShowCreateModal(true); setCreateError(''); }}>
              <span className="flex items-center gap-1.5">
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>
                Create New Trial
              </span>
            </Button>
          </div>
        </div>

        <div className="p-3 rounded-lg text-sm flex items-start gap-2" style={{ background: 'var(--status-info-bg)', border: '1px solid var(--status-info-border)', color: 'var(--status-info)' }}>
          <svg className="w-5 h-5 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
          <span><strong>Federated Privacy:</strong> Only drug names and eligibility parameters are shared. No patient IDs or private records leave your hospital.</span>
        </div>
      </Card>

      <div>
        <input type="text" placeholder="Search by drug name or disease..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="input" />
      </div>

      {loading ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {Array.from({ length: 6 }).map((_, i) => <CardSkeleton key={i} lines={5} />)}
        </div>
      ) : filtered.length === 0 ? (
        <Card><div className="text-center py-12" style={{ color: 'var(--text-tertiary)' }}>No trials found. Upload patient data first.</div></Card>
      ) : (
        <motion.div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 auto-rows-fr" variants={staggerContainer} initial="hidden" animate="visible">
          {filtered.map((trial) => (
            <motion.div key={trial.id} variants={staggerItem} className="h-full">
              <Card hover onClick={() => handleSelectTrial(trial)} className="cursor-pointer h-full flex flex-col">
                <div className="flex justify-between items-start mb-2">
                  <h3 className="font-bold text-lg" style={{ color: 'var(--text-primary)' }}>{trial.drugName}</h3>
                  <StatusBadge status={trial.status} />
                </div>
                <p className="text-sm mb-3" style={{ color: 'var(--text-secondary)' }}>Treats: {trial.indication}</p>

                {trial.eligibleFromCurrent != null && (
                  <div className="mb-3 p-2 rounded-lg flex items-center gap-2" style={{ background: 'var(--status-success-bg)', border: '1px solid var(--status-success-border)' }}>
                    <svg className="w-5 h-5 flex-shrink-0" style={{ color: 'var(--status-success)' }} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    <span className="text-sm" style={{ color: 'var(--status-success)' }}><strong>{trial.eligibleFromCurrent}</strong> patient{trial.eligibleFromCurrent !== 1 ? 's' : ''} eligible from your data</span>
                  </div>
                )}

                <div className="flex-1">
                  {trial.eligibilityParams && (
                    <div className="space-y-1.5 mb-3">
                      {trial.eligibilityParams.ageRange && (
                        <div className="flex items-center gap-2 text-xs"><span className="w-20 flex-shrink-0" style={{ color: 'var(--text-tertiary)' }}>Age:</span><span className="font-medium" style={{ color: 'var(--text-primary)' }}>{trial.eligibilityParams.ageRange[0]} – {trial.eligibilityParams.ageRange[1]} yrs</span></div>
                      )}
                      {trial.eligibilityParams.genders?.length > 0 && (
                        <div className="flex items-center gap-2 text-xs"><span className="w-20 flex-shrink-0" style={{ color: 'var(--text-tertiary)' }}>Gender:</span><span className="font-medium" style={{ color: 'var(--text-primary)' }}>{trial.eligibilityParams.genders.join(', ')}</span></div>
                      )}
                      {trial.eligibilityParams.bloodGroups?.length > 0 && (
                        <div className="flex items-center gap-2 text-xs"><span className="w-20 flex-shrink-0" style={{ color: 'var(--text-tertiary)' }}>Blood:</span><div className="flex gap-1 flex-wrap">{trial.eligibilityParams.bloodGroups.map(bg => <span key={bg} className="badge" style={{ background: 'var(--status-error-bg)', color: 'var(--status-error)' }}>{bg}</span>)}</div></div>
                      )}
                      {trial.eligibilityParams.bmiRange && (
                        <div className="flex items-center gap-2 text-xs"><span className="w-20 flex-shrink-0" style={{ color: 'var(--text-tertiary)' }}>BMI:</span><span className="font-medium" style={{ color: 'var(--text-primary)' }}>{trial.eligibilityParams.bmiRange[0]} – {trial.eligibilityParams.bmiRange[1]}</span></div>
                      )}
                      {trial.eligibilityParams.stages?.length > 0 && (
                        <div className="flex items-center gap-2 text-xs"><span className="w-20 flex-shrink-0" style={{ color: 'var(--text-tertiary)' }}>Stages:</span><span className="font-medium" style={{ color: 'var(--text-primary)' }}>{trial.eligibilityParams.stages.join(', ')}</span></div>
                      )}
                      {trial.eligibilityParams.commonComorbidities?.length > 0 && (
                        <div className="flex items-center gap-2 text-xs"><span className="w-20 flex-shrink-0" style={{ color: 'var(--text-tertiary)' }}>Comorbid.:</span><span className="font-medium" style={{ color: 'var(--text-primary)' }}>{trial.eligibilityParams.commonComorbidities.join(', ')}</span></div>
                      )}
                    </div>
                  )}
                </div>

                <div className="flex gap-3 text-xs pt-2 mt-auto" style={{ borderTop: '1px solid var(--border-primary)', color: 'var(--text-tertiary)' }}>
                  <span>Enrolled: <strong style={{ color: 'var(--text-primary)' }}>{trial.patientsEnrolled}</strong></span>
                  <span>Success: <strong style={{ color: 'var(--status-success)' }}>{trial.successRate}%</strong></span>
                </div>
              </Card>
            </motion.div>
          ))}
        </motion.div>
      )}

      {/* Create Trial Modal */}
      <AnimatePresence>
        {showCreateModal && (
          <motion.div
            initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
            className="fixed inset-0 z-50 flex items-center justify-center p-4"
            style={{ background: 'rgba(0,0,0,0.5)', backdropFilter: 'blur(4px)' }}
            onClick={() => setShowCreateModal(false)}
          >
            <motion.div
              initial={{ opacity: 0, scale: 0.95, y: 20 }} animate={{ opacity: 1, scale: 1, y: 0 }} exit={{ opacity: 0, scale: 0.95, y: 20 }}
              className="w-full max-w-md rounded-2xl shadow-2xl p-6"
              style={{ background: 'var(--bg-card)', border: '1px solid var(--border-primary)' }}
              onClick={(e) => e.stopPropagation()}
            >
              <div className="flex items-center justify-between mb-5">
                <div className="flex items-center gap-2">
                  <div className="w-1.5 h-6 rounded-full" style={{ background: 'var(--brand-primary)' }} />
                  <h3 className="text-lg font-bold" style={{ color: 'var(--text-primary)' }}>Create New Trial</h3>
                </div>
                <button onClick={() => setShowCreateModal(false)} className="w-8 h-8 rounded-lg flex items-center justify-center transition" style={{ color: 'var(--text-tertiary)', background: 'var(--bg-tertiary)' }}>
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
              </div>

              <form onSubmit={handleCreateTrial} className="space-y-4">
                <div>
                  <label className="block text-xs font-semibold mb-1.5 uppercase tracking-wider" style={{ color: 'var(--text-tertiary)' }}>Drug Name *</label>
                  <input type="text" required value={newTrial.drugName} onChange={(e) => setNewTrial(p => ({ ...p, drugName: e.target.value }))} placeholder="e.g. Cardiozen-X" className="input w-full" />
                </div>
                <div>
                  <label className="block text-xs font-semibold mb-1.5 uppercase tracking-wider" style={{ color: 'var(--text-tertiary)' }}>Indication (Disease) *</label>
                  <input type="text" required value={newTrial.indication} onChange={(e) => setNewTrial(p => ({ ...p, indication: e.target.value }))} placeholder="e.g. Heart Disease" className="input w-full" />
                </div>
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="block text-xs font-semibold mb-1.5 uppercase tracking-wider" style={{ color: 'var(--text-tertiary)' }}>Phase</label>
                    <select value={newTrial.phase} onChange={(e) => setNewTrial(p => ({ ...p, phase: e.target.value }))} className="input w-full" style={{ background: 'var(--bg-secondary)', color: 'var(--text-primary)', border: '1px solid var(--border-primary)', borderRadius: 'var(--radius-md)', padding: '0.5rem 0.75rem' }}>
                      <option value="Phase I">Phase I</option>
                      <option value="Phase II">Phase II</option>
                      <option value="Phase III">Phase III</option>
                      <option value="Phase IV">Phase IV</option>
                    </select>
                  </div>
                  <div>
                    <label className="block text-xs font-semibold mb-1.5 uppercase tracking-wider" style={{ color: 'var(--text-tertiary)' }}>Status</label>
                    <select value={newTrial.status} onChange={(e) => setNewTrial(p => ({ ...p, status: e.target.value }))} className="input w-full" style={{ background: 'var(--bg-secondary)', color: 'var(--text-primary)', border: '1px solid var(--border-primary)', borderRadius: 'var(--radius-md)', padding: '0.5rem 0.75rem' }}>
                      <option value="Active">Active</option>
                      <option value="Completed">Completed</option>
                      <option value="Suspended">Suspended</option>
                    </select>
                  </div>
                </div>
                <div>
                  <label className="block text-xs font-semibold mb-1.5 uppercase tracking-wider" style={{ color: 'var(--text-tertiary)' }}>Success Rate (%)</label>
                  <input type="number" min="0" max="100" step="0.1" value={newTrial.successRate} onChange={(e) => setNewTrial(p => ({ ...p, successRate: e.target.value }))} placeholder="e.g. 65.0" className="input w-full" />
                </div>

                {createError && (
                  <div className="p-2.5 rounded-lg text-sm" style={{ background: 'var(--status-error-bg)', color: 'var(--status-error)', border: '1px solid var(--status-error-border)' }}>{createError}</div>
                )}

                <div className="flex gap-3 pt-2">
                  <Button type="button" variant="secondary" onClick={() => setShowCreateModal(false)} className="flex-1">Cancel</Button>
                  <Button type="submit" variant="primary" disabled={creating} className="flex-1">
                    {creating ? 'Creating...' : 'Create & Publish'}
                  </Button>
                </div>
              </form>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
}


================================================================================
--- FILE: .\frontend\src\components\ui\Button.jsx ---
================================================================================
import React, { memo, forwardRef } from 'react';
import { motion } from 'framer-motion';

const variants = {
  primary: 'btn-primary',
  secondary: 'btn-secondary',
  danger: 'btn-danger',
  ghost: 'btn-ghost',
};

const sizes = {
  sm: 'text-xs px-3 py-1.5',
  md: 'text-sm px-4 py-2',
  lg: 'text-base px-5 py-2.5',
};

const Button = memo(forwardRef(function Button(
  { variant = 'primary', size = 'md', children, className = '', disabled, loading, icon, ...props },
  ref
) {
  return (
    <motion.button
      ref={ref}
      className={`btn ${variants[variant]} ${sizes[size]} ${className}`}
      disabled={disabled || loading}
      whileHover={!disabled ? { scale: 1.02 } : {}}
      whileTap={!disabled ? { scale: 0.97 } : {}}
      {...props}
    >
      {loading ? (
        <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24" fill="none">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z" />
        </svg>
      ) : icon ? (
        <span className="w-4 h-4 flex-shrink-0">{icon}</span>
      ) : null}
      {children}
    </motion.button>
  );
}));

export default Button;


================================================================================
--- FILE: .\frontend\src\components\ui\Card.jsx ---
================================================================================
import React, { memo } from 'react';
import { motion } from 'framer-motion';

const Card = memo(function Card({
  children,
  className = '',
  hover = false,
  glow = false,
  padding = 'p-5',
  onClick,
  ...props
}) {
  return (
    <motion.div
      className={`glass-card ${padding} ${onClick ? 'cursor-pointer' : ''} ${className}`}
      whileHover={hover ? { y: -2, scale: 1.005 } : {}}
      whileTap={onClick ? { scale: 0.99 } : {}}
      onClick={onClick}
      layout
      {...props}
    >
      {children}
    </motion.div>
  );
});

export default Card;


================================================================================
--- FILE: .\frontend\src\components\ui\index.js ---
================================================================================
export { default as Button } from './Button';
export { default as Card } from './Card';
export { default as ThemeToggle } from './ThemeToggle';
export { default as StatusBadge } from './StatusBadge';
export { default as Skeleton, TableSkeleton, CardSkeleton } from './Skeleton';
export { ToastProvider, useToast } from './Toast';


================================================================================
--- FILE: .\frontend\src\components\ui\Skeleton.jsx ---
================================================================================
import React, { memo } from 'react';

const Skeleton = memo(function Skeleton({ className = '', rows = 1, height = 'h-4', width = 'w-full' }) {
  if (rows === 1) return <div className={`skeleton ${height} ${width} ${className}`} />;
  return (
    <div className={`space-y-2 ${className}`}>
      {Array.from({ length: rows }).map((_, i) => (
        <div
          key={i}
          className={`skeleton ${height}`}
          style={{ width: i === rows - 1 ? '60%' : '100%' }}
        />
      ))}
    </div>
  );
});

export const TableSkeleton = memo(function TableSkeleton({ cols = 5, rows = 8 }) {
  return (
    <div className="space-y-1">
      <div className="skeleton h-10 w-full rounded-t-lg" />
      {Array.from({ length: rows }).map((_, r) => (
        <div key={r} className="flex gap-2">
          {Array.from({ length: cols }).map((_, c) => (
            <div key={c} className="skeleton h-8 flex-1" />
          ))}
        </div>
      ))}
    </div>
  );
});

export const CardSkeleton = memo(function CardSkeleton() {
  return (
    <div className="glass-card p-5 space-y-3">
      <div className="skeleton h-5 w-2/3" />
      <div className="skeleton h-4 w-full" />
      <div className="skeleton h-4 w-4/5" />
      <div className="flex gap-2 pt-2">
        <div className="skeleton h-6 w-16 rounded-full" />
        <div className="skeleton h-6 w-20 rounded-full" />
      </div>
    </div>
  );
});

export default Skeleton;


================================================================================
--- FILE: .\frontend\src\components\ui\StatusBadge.jsx ---
================================================================================
import React, { memo } from 'react';
import { useThemeStore } from '../../stores/themeStore';

const statusConfig = {
  Active:    { light: { bg: '#ECFDF5', text: '#059669', border: '#A7F3D0' }, dark: { bg: 'rgba(32,227,178,0.1)',  text: '#20E3B2', border: 'rgba(32,227,178,0.25)' } },
  Completed: { light: { bg: '#EEF2FF', text: '#4F46E5', border: '#C7D2FE' }, dark: { bg: 'rgba(51,154,240,0.1)',  text: '#74C0FC', border: 'rgba(51,154,240,0.25)' } },
  Paused:    { light: { bg: '#FFFBEB', text: '#B45309', border: '#FDE68A' }, dark: { bg: 'rgba(255,212,59,0.1)',  text: '#FFD43B', border: 'rgba(255,212,59,0.2)' } },
  Training:  { light: { bg: '#F0F9FF', text: '#0284C7', border: '#BAE6FD' }, dark: { bg: 'rgba(32,227,178,0.08)', text: '#20E3B2', border: 'rgba(32,227,178,0.15)' } },
  Ready:     { light: { bg: '#ECFDF5', text: '#059669', border: '#A7F3D0' }, dark: { bg: 'rgba(32,227,178,0.1)',  text: '#20E3B2', border: 'rgba(32,227,178,0.25)' } },
  Error:     { light: { bg: '#FEF2F2', text: '#DC2626', border: '#FECACA' }, dark: { bg: 'rgba(255,107,107,0.1)', text: '#FF6B6B', border: 'rgba(255,107,107,0.25)' } },
  Idle:      { light: { bg: '#F0F2F8', text: '#6366F1', border: '#E0E4F0' }, dark: { bg: 'rgba(56,78,124,0.2)',   text: '#94A3B8', border: 'rgba(56,78,124,0.3)' } },
};

const StatusBadge = memo(function StatusBadge({ status = 'Idle', pulse = true }) {
  const theme = useThemeStore((s) => s.theme);
  const config = statusConfig[status] || statusConfig.Idle;
  const colors = config[theme === 'dark' ? 'dark' : 'light'];
  const isLive = (status === 'Active' || status === 'Training') && pulse;

  return (
    <span
      className="badge"
      style={{
        background: colors.bg,
        color: colors.text,
        border: `1px solid ${colors.border}`,
      }}
    >
      {isLive && (
        <span
          className="pulse-dot"
          style={{ backgroundColor: colors.text, color: colors.text }}
        />
      )}
      {status}
    </span>
  );
});

export default StatusBadge;


================================================================================
--- FILE: .\frontend\src\components\ui\ThemeToggle.jsx ---
================================================================================
import React, { memo } from 'react';
import { motion } from 'framer-motion';
import { useThemeStore } from '../../stores/themeStore';

const ThemeToggle = memo(function ThemeToggle() {
  const { theme, toggleTheme } = useThemeStore();
  const isDark = theme === 'dark';

  return (
    <motion.button
      onClick={toggleTheme}
      className="relative w-14 h-7 rounded-full p-0.5 focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2"
      style={{
        background: isDark
          ? 'linear-gradient(135deg, #0B132B, #1C7ED6)'
          : 'linear-gradient(135deg, #E0E4F0, #C7D2FE)',
        boxShadow: isDark
          ? '0 0 12px rgba(32, 227, 178, 0.2), inset 0 1px 2px rgba(0,0,0,0.3)'
          : 'inset 0 1px 3px rgba(99,102,241,0.15)',
      }}
      whileTap={{ scale: 0.95 }}
      aria-label={isDark ? 'Switch to light mode' : 'Switch to dark mode'}
      title={isDark ? 'TechLux Platinum (Light)' : 'BioTech Elite (Dark)'}
    >
      <motion.div
        className="w-6 h-6 rounded-full flex items-center justify-center"
        style={{
          background: isDark ? '#162040' : '#FFFFFF',
          boxShadow: isDark
            ? '0 0 8px rgba(32, 227, 178, 0.3)'
            : '0 1px 4px rgba(99,102,241,0.2)',
        }}
        layout
        animate={{ x: isDark ? 26 : 0 }}
        transition={{ type: 'spring', stiffness: 500, damping: 30 }}
      >
        {isDark ? (
          <svg className="w-3.5 h-3.5 text-[#20E3B2]" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
          </svg>
        ) : (
          <svg className="w-3.5 h-3.5 text-[#6366F1]" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
          </svg>
        )}
      </motion.div>
    </motion.button>
  );
});

export default ThemeToggle;


================================================================================
--- FILE: .\frontend\src\components\ui\Toast.jsx ---
================================================================================
import React, { memo, useState, useCallback, useEffect, createContext, useContext } from 'react';
import { motion, AnimatePresence } from 'framer-motion';

const ToastContext = createContext(null);

const ICONS = {
  success: (
    <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
    </svg>
  ),
  error: (
    <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
    </svg>
  ),
  info: (
    <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
  ),
  warning: (
    <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.072 16.5c-.77.833.192 2.5 1.732 2.5z" />
    </svg>
  ),
};

const STYLES = {
  success: { bg: 'var(--status-success-bg)', border: 'var(--status-success-border)', text: 'var(--status-success)' },
  error:   { bg: 'var(--status-error-bg)',   border: 'var(--status-error-border)',   text: 'var(--status-error)' },
  info:    { bg: 'var(--status-info-bg)',     border: 'var(--status-info-border)',     text: 'var(--status-info)' },
  warning: { bg: 'var(--status-warning-bg)', border: 'var(--status-warning-border)', text: 'var(--status-warning)' },
};

let toastId = 0;

export function ToastProvider({ children }) {
  const [toasts, setToasts] = useState([]);

  const addToast = useCallback((message, type = 'info', duration = 4000) => {
    const id = ++toastId;
    setToasts((prev) => [...prev, { id, message, type, duration }]);
    if (duration > 0) setTimeout(() => removeToast(id), duration);
    return id;
  }, []);

  const removeToast = useCallback((id) => {
    setToasts((prev) => prev.filter((t) => t.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ addToast, removeToast }}>
      {children}
      <div className="fixed top-4 right-4 z-[100] flex flex-col gap-2 max-w-sm">
        <AnimatePresence>
          {toasts.map((t) => (
            <ToastItem key={t.id} toast={t} onClose={() => removeToast(t.id)} />
          ))}
        </AnimatePresence>
      </div>
    </ToastContext.Provider>
  );
}

const ToastItem = memo(function ToastItem({ toast, onClose }) {
  const s = STYLES[toast.type] || STYLES.info;
  return (
    <motion.div
      initial={{ opacity: 0, y: -12, scale: 0.96 }}
      animate={{ opacity: 1, y: 0, scale: 1 }}
      exit={{ opacity: 0, y: -12, scale: 0.96 }}
      transition={{ duration: 0.25 }}
      className="glass-card flex items-start gap-3 p-3 pr-10 relative"
      style={{ background: s.bg, borderColor: s.border }}
      role="alert"
    >
      <span style={{ color: s.text }} className="flex-shrink-0 mt-0.5">{ICONS[toast.type]}</span>
      <p className="text-sm font-medium" style={{ color: s.text }}>{toast.message}</p>
      <button
        onClick={onClose}
        className="absolute top-2 right-2 p-1 rounded-full hover:opacity-70"
        style={{ color: s.text }}
        aria-label="Dismiss"
      >
        <svg className="w-3.5 h-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </motion.div>
  );
});

export function useToast() {
  const ctx = useContext(ToastContext);
  if (!ctx) throw new Error('useToast must be used inside <ToastProvider>');
  return ctx;
}


================================================================================
--- FILE: .\frontend\src\hooks\useBlockchainLogs.js ---
================================================================================
import { useState, useEffect, useRef, useCallback } from 'react';
import { apiService } from '../services/apiService';

export function useBlockchainLogs(enabled = false, pollInterval = 12000) {
  const [logs, setLogs] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const intervalRef = useRef(null);
  const lastHash = useRef('');  // dedup: skip re-render if data unchanged

  const fetchFromBackend = useCallback(async () => {
    try {
      const backendLogs = await apiService.getBlockchainLogs();
      const list = Array.isArray(backendLogs) ? backendLogs : [];
      // Quick hash: compare count + newest txHash to avoid re-renders
      const hash = `${list.length}_${list[0]?.txHash || ''}`;
      if (hash !== lastHash.current) {
        lastHash.current = hash;
        setLogs(list);
      }
      setError(null);
      setLoading(false);
    } catch (err) {
      setError(err);
      setLoading(false);
    }
  }, []);

  const refresh = useCallback(async () => {
    await fetchFromBackend();
  }, [fetchFromBackend]);

  useEffect(() => {
    if (!enabled) return;
    let mounted = true;
    (async () => {
      try {
        if (!mounted) return;
        await refresh();
      } catch (err) {
        if (mounted) setError(err);
      } finally {
        if (mounted) setLoading(false);
      }
    })();
    return () => { mounted = false; };
  }, [refresh, enabled]);

  useEffect(() => {
    if (!enabled) {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
      return;
    }

    refresh();
    intervalRef.current = setInterval(fetchFromBackend, pollInterval);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [enabled, pollInterval, refresh, fetchFromBackend]);

  return { logs, loading, error, refresh };
}


================================================================================
--- FILE: .\frontend\src\hooks\useTrainingData.js ---
================================================================================
import { useState, useEffect, useRef, useCallback } from 'react';
import { apiService } from '../services/apiService';

export function useTrainingData(pollInterval = 5000) {
  const [trainingLogs, setTrainingLogs] = useState([]);
  const [isTraining, setIsTraining] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const intervalRef = useRef(null);

  const fetchLogs = useCallback(async () => {
    try {
      const logs = await apiService.getTrainingLogs();
      setTrainingLogs(Array.isArray(logs) ? logs : []);
    } catch (err) {
      setError(err);
    }
  }, []);

  const fetchStatus = useCallback(async () => {
    try {
      const status = await apiService.getTrainingStatus();
      setIsTraining(Boolean(status?.is_training));
      return status;
    } catch (err) {
      setError(err);
      return null;
    }
  }, []);

  const startPolling = useCallback(() => {
    if (intervalRef.current) return;
    intervalRef.current = setInterval(async () => {
      await fetchLogs();
      const status = await fetchStatus();
      if (!status || !status.is_training) {
        // stop polling if training finished
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    }, pollInterval);
  }, [fetchLogs, fetchStatus, pollInterval]);

  const stopPolling = useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);

  const startTraining = useCallback(async (config) => {
    setLoading(true);
    setError(null);
    try {
      await apiService.startTraining(config);
      setIsTraining(true);
      await fetchLogs();
      startPolling();
    } catch (err) {
      setError(err);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [fetchLogs, startPolling]);

  const stopTraining = useCallback(async () => {
    try {
      await apiService.stopTraining();
    } catch (err) {
      console.error('stopTraining error', err);
    } finally {
      setIsTraining(false);
      stopPolling();
      await fetchLogs();
    }
  }, [stopPolling, fetchLogs]);

  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const status = await fetchStatus();
        if (mounted) {
          setIsTraining(Boolean(status?.is_training));
        }
        await fetchLogs();
      } catch (err) {
        if (mounted) setError(err);
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
      stopPolling();
    };
  }, [fetchLogs, fetchStatus, stopPolling]);

  return {
    trainingLogs,
    isTraining,
    loading,
    error,
    startTraining,
    stopTraining,
    startPolling,
    stopPolling,
    refresh: fetchLogs,
  };
}


================================================================================
--- FILE: .\frontend\src\services\apiService.js ---
================================================================================
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;

export const apiService = {
  // Login to the backend (MongoDB-backed authentication)
  login: async (username, password) => {
    try {
      const response = await axios.post(`${API_BASE_URL}/auth/login`, { username, password });
      return response.data;
    } catch (error) {
      if (error.response && error.response.status === 401) {
        throw new Error('Invalid username or password');
      }
      console.error('Error logging in:', error);
      throw error;
    }
  },

  // Get fast overview stats (no heavy data transfer)
  getStats: async (hospital) => {
    try {
      const params = hospital ? `?hospital=${encodeURIComponent(hospital)}` : '';
      const response = await axios.get(`${API_BASE_URL}/stats${params}`);
      return response.data;
    } catch (error) {
      console.error('Error getting stats:', error);
      throw error;
    }
  },

  // Get hospital details
  getHospitalDetails: async () => {
    try {
      const response = await axios.get(`${API_BASE_URL}/stats/hospitals`);
      return response.data;
    } catch (error) {
      console.error('Error getting hospital details:', error);
      throw error;
    }
  },

  // Get disease breakdown
  getDiseaseBreakdown: async () => {
    try {
      const response = await axios.get(`${API_BASE_URL}/stats/diseases`);
      return response.data;
    } catch (error) {
      console.error('Error getting disease breakdown:', error);
      throw error;
    }
  },

  // Start federated training
  startTraining: async (config) => {
    try {
      const response = await axios.post(`${API_BASE_URL}/start-training`, config);
      return response.data;
    } catch (error) {
      console.error('Error starting training:', error);
      throw error;
    }
  },

  // Get training status
  getTrainingStatus: async () => {
    try {
      const response = await axios.get(`${API_BASE_URL}/training-status`);
      return response.data;
    } catch (error) {
      console.error('Error getting training status:', error);
      throw error;
    }
  },

  // Get training logs
  getTrainingLogs: async () => {
    try {
      const response = await axios.get(`${API_BASE_URL}/training-logs`);
      return response.data;
    } catch (error) {
      console.error('Error getting training logs:', error);
      throw error;
    }
  },

  // Stop training
  stopTraining: async () => {
    try {
      const response = await axios.post(`${API_BASE_URL}/stop-training`);
      return response.data;
    } catch (error) {
      console.error('Error stopping training:', error);
      throw error;
    }
  },

  // Get patients (paginated, with server-side search & sort)
  getPatients: async (hospital, { page = 1, pageSize = 50, search = '', sortBy = '', sortDir = 'asc' } = {}) => {
    try {
      const params = new URLSearchParams();
      if (hospital) params.set('hospital', hospital);
      params.set('page', page);
      params.set('page_size', pageSize);
      if (search) params.set('search', search);
      if (sortBy) { params.set('sort_by', sortBy); params.set('sort_dir', sortDir); }
      const response = await axios.get(`${API_BASE_URL}/patients?${params.toString()}`);
      return response.data;
    } catch (error) {
      console.error('Error getting patients:', error);
      throw error;
    }
  },

  // Get all trials (drug names + anonymized eligibility parameters)
  getTrials: async (hospital) => {
    try {
      const params = hospital ? `?hospital=${encodeURIComponent(hospital)}` : '';
      const response = await axios.get(`${API_BASE_URL}/trials${params}`);
      return response.data;
    } catch (error) {
      console.error('Error getting trials:', error);
      throw error;
    }
  },

  // Create a new trial
  createTrial: async (trialData, hospital) => {
    try {
      const params = hospital ? `?hospital=${encodeURIComponent(hospital)}` : '';
      const response = await axios.post(`${API_BASE_URL}/trials${params}`, trialData);
      return response.data;
    } catch (error) {
      console.error('Error creating trial:', error);
      throw error;
    }
  },

  // Get eligible patients for a specific drug (paginated)
  getEligibleForDrug: async (drugName, hospital, { page = 1, pageSize = 50, tab = 'eligible' } = {}) => {
    try {
      const params = new URLSearchParams();
      if (hospital) params.set('hospital', hospital);
      params.set('page', page);
      params.set('page_size', pageSize);
      params.set('tab', tab);
      const response = await axios.get(`${API_BASE_URL}/trials/${encodeURIComponent(drugName)}/eligible?${params}`);
      return response.data;
    } catch (error) {
      console.error('Error getting eligible patients:', error);
      throw error;
    }
  },

  // Unified upload (CSV, JSON, PDF) — preprocessed on backend
  // Returns { data, uploadId } so caller can poll progress
  uploadFile: async (file, hospital, onUploadProgress) => {
    try {
      const formData = new FormData();
      formData.append('file', file);
      if (hospital) formData.append('hospital', hospital);
      const params = hospital ? `?hospital=${encodeURIComponent(hospital)}` : '';
      const response = await axios.post(`${API_BASE_URL}/upload${params}`, formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
        onUploadProgress: onUploadProgress || undefined,
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading file:', error);
      throw error;
    }
  },

  // Poll preprocessing progress by upload_id
  getUploadProgress: async (uploadId) => {
    try {
      const response = await axios.get(`${API_BASE_URL}/upload-progress/${uploadId}`);
      return response.data;
    } catch (error) {
      return { percent: 0, stage: 'waiting' };
    }
  },

  // Upload JSON file
  uploadJson: async (file) => {
    try {
      const formData = new FormData();
      formData.append('file', file);
      const response = await axios.post(`${API_BASE_URL}/upload-json`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading JSON:', error);
      throw error;
    }
  },

  // Upload PDF file
  uploadPdf: async (file) => {
    try {
      const formData = new FormData();
      formData.append('file', file);
      const response = await axios.post(`${API_BASE_URL}/upload-pdf`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading PDF:', error);
      throw error;
    }
  },

  // Upload CSV file
  uploadCsv: async (file) => {
    try {
      const formData = new FormData();
      formData.append('file', file);
      const response = await axios.post(`${API_BASE_URL}/upload-csv`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading CSV:', error);
      throw error;
    }
  },

  // Get blockchain logs from backend
  getBlockchainLogs: async () => {
    try {
      const response = await axios.get(`${API_BASE_URL}/blockchain-logs`);
      // New dedicated endpoint returns { logs: [...], total: N }
      return response.data.logs || [];
    } catch (error) {
      console.error('Error getting blockchain logs:', error);
      // Fallback to model-metrics if /blockchain-logs not available
      try {
        const fallback = await axios.get(`${API_BASE_URL}/model-metrics`);
        return fallback.data.blockchain_logs || [];
      } catch {
        return [];
      }
    }
  },

  // Log a frontend activity to the blockchain audit trail (fire-and-forget)
  logActivity: (action, details = '', actor = 'Unknown Hospital', recordCount = 0) => {
    axios.post(`${API_BASE_URL}/log-activity`, { action, details, actor, record_count: recordCount }).catch(() => {});
  },

  // Predict patient eligibility
  predictEligibility: async (patientData) => {
    try {
      const response = await axios.post(`${API_BASE_URL}/predict`, patientData);
      return response.data;
    } catch (error) {
      console.error('Error predicting eligibility:', error);
      throw error;
    }
  },
};


================================================================================
--- FILE: .\frontend\src\stores\themeStore.js ---
================================================================================
import { create } from 'zustand';

const STORAGE_KEY = 'medfed-theme';

function getSystemPreference() {
  if (typeof window === 'undefined') return 'dark';
  return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
}

function getSavedTheme() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved === 'dark' || saved === 'light') return saved;
  } catch { /* ignore */ }
  return null;
}

export const useThemeStore = create((set, get) => ({
  theme: getSavedTheme() || getSystemPreference(),

  toggleTheme: () => {
    const next = get().theme === 'dark' ? 'light' : 'dark';
    set({ theme: next });
    try { localStorage.setItem(STORAGE_KEY, next); } catch { /* ignore */ }
    applyThemeToDOM(next);
  },

  setTheme: (t) => {
    set({ theme: t });
    try { localStorage.setItem(STORAGE_KEY, t); } catch { /* ignore */ }
    applyThemeToDOM(t);
  },

  isDark: () => get().theme === 'dark',
}));

/** Apply / remove the `dark` class on <html> for Tailwind + CSS-variable switching */
export function applyThemeToDOM(theme) {
  const root = document.documentElement;
  if (theme === 'dark') {
    root.classList.add('dark');
    root.setAttribute('data-theme', 'dark');
  } else {
    root.classList.remove('dark');
    root.setAttribute('data-theme', 'light');
  }
}

// Initialise on first load
applyThemeToDOM(getSavedTheme() || getSystemPreference());


================================================================================
--- FILE: .\frontend\src\utils\motionVariants.js ---
================================================================================
/** Shared Framer Motion variant presets */

export const fadeIn = {
  hidden: { opacity: 0 },
  visible: { opacity: 1, transition: { duration: 0.3 } },
  exit: { opacity: 0, transition: { duration: 0.2 } },
};

export const slideUp = {
  hidden: { opacity: 0, y: 16 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.35, ease: [0.4, 0, 0.2, 1] } },
  exit: { opacity: 0, y: 16, transition: { duration: 0.2 } },
};

export const scaleIn = {
  hidden: { opacity: 0, scale: 0.96 },
  visible: { opacity: 1, scale: 1, transition: { type: 'spring', stiffness: 400, damping: 28 } },
  exit: { opacity: 0, scale: 0.96, transition: { duration: 0.2 } },
};

export const staggerContainer = {
  hidden: {},
  visible: { transition: { staggerChildren: 0.06 } },
};

export const staggerItem = {
  hidden: { opacity: 0, y: 12 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.3, ease: [0.4, 0, 0.2, 1] } },
};

/** Page-level wrapper for animated route / tab content */
export const pageTransition = {
  initial: { opacity: 0, y: 8 },
  animate: { opacity: 1, y: 0 },
  exit: { opacity: 0, y: -8 },
  transition: { duration: 0.25 },
};


================================================================================
--- FILE: .\scripts\assign_hospitals.py ---
================================================================================
"""
Assign existing patients to hospitals.

Each patient gets a `hospital_name` field matching one of the registered
hospital accounts.  The distribution is equal (~20% each):

  - Sai Prasad Medical Science   ~20 %
  - Apollo Hospitals              ~20 %
  - KIMS Hospital                 ~20 %
  - Medicover Hospital            ~20 %
  - Citizens Hospital             ~20 %

Patients that already have a `hospital_name` are skipped.
"""

import os
import sys
import random

sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))

from pymongo import MongoClient, UpdateOne
from dotenv import load_dotenv

load_dotenv(os.path.join(os.path.dirname(__file__), "..", ".env"))

MONGO_URI = os.getenv("MONGO_URI")
DB_NAME = os.getenv("MONGO_DB_NAME")

HOSPITALS = [
    ("Sai Prasad Medical Science", 20),
    ("Apollo Hospitals", 20),
    ("KIMS Hospital", 20),
    ("Medicover Hospital", 20),
    ("Citizens Hospital", 20),
]


def _weighted_choice():
    """Return a hospital name based on configured weights."""
    names, weights = zip(*HOSPITALS)
    return random.choices(names, weights=weights, k=1)[0]


def main():
    client = MongoClient(MONGO_URI)
    db = client[DB_NAME]
    col = db.patients

    # Find patients without hospital_name
    patients = list(col.find(
        {"$or": [
            {"hospital_name": {"$exists": False}},
            {"hospital_name": None},
            {"hospital_name": ""},
        ]},
        {"_id": 1},
    ))

    total = len(patients)
    if total == 0:
        # Check current distribution
        pipeline = [
            {"$group": {"_id": "$hospital_name", "count": {"$sum": 1}}},
            {"$sort": {"count": -1}},
        ]
        print("All patients already have a hospital_name assigned.")
        print("\nCurrent distribution:")
        for doc in col.aggregate(pipeline):
            print(f"  {doc['_id']}: {doc['count']} patients")
        return

    print(f"Assigning hospital_name to {total} patients...")

    ops = []
    counts = {h: 0 for h, _ in HOSPITALS}

    for i, p in enumerate(patients):
        hosp = _weighted_choice()
        counts[hosp] += 1
        ops.append(UpdateOne({"_id": p["_id"]}, {"$set": {"hospital_name": hosp}}))

        if len(ops) >= 500:
            col.bulk_write(ops)
            print(f"  ... assigned {i + 1}/{total}")
            ops = []

    if ops:
        col.bulk_write(ops)

    print(f"\nDone! Assigned {total} patients:")
    for hosp, cnt in sorted(counts.items(), key=lambda x: -x[1]):
        print(f"  {hosp}: {cnt} patients ({cnt * 100 // total}%)")

    # Verify with aggregation
    print("\nVerification (from MongoDB):")
    pipeline = [
        {"$group": {"_id": "$hospital_name", "count": {"$sum": 1}}},
        {"$sort": {"count": -1}},
    ]
    for doc in col.aggregate(pipeline):
        print(f"  {doc['_id']}: {doc['count']} patients")


if __name__ == "__main__":
    main()


================================================================================
--- FILE: .\scripts\seed_personal_details.py ---
================================================================================
"""
Seed personal details (name, phone, email, address, emergency_contact, admission_date)
into existing patients in MongoDB that don't already have them.
"""
import os, sys, random, hashlib
from datetime import datetime, timedelta

sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))

from pymongo import MongoClient, UpdateOne
from dotenv import load_dotenv

load_dotenv(os.path.join(os.path.dirname(__file__), "..", ".env"))

MONGO_URI = "mongodb+srv://yb15313037_db_user:D09J5gpczE2QAAD8@cluster0.oxujjgd.mongodb.net/"
DB_NAME = "federated_screener"

# ---------- Realistic Indian name pools ----------
FIRST_NAMES_MALE = [
    "Aarav", "Vivaan", "Aditya", "Vihaan", "Arjun", "Sai", "Reyansh", "Ayaan",
    "Krishna", "Ishaan", "Shaurya", "Atharva", "Advait", "Dhruv", "Kabir",
    "Ritvik", "Aarush", "Kian", "Darsh", "Veer", "Yash", "Rohan", "Arnav",
    "Laksh", "Pranav", "Rudra", "Aadit", "Kiaan", "Sahil", "Ravi",
    "Suresh", "Mahesh", "Rajesh", "Ganesh", "Dinesh", "Ramesh", "Naresh",
    "Mukesh", "Prakash", "Vikram", "Amit", "Sumit", "Ankit", "Nikhil",
    "Rahul", "Deepak", "Manoj", "Sanjay", "Ajay", "Vijay", "Karthik",
    "Harish", "Pradeep", "Mohan", "Gopal", "Venkat", "Srikanth", "Naveen",
]

FIRST_NAMES_FEMALE = [
    "Saanvi", "Aanya", "Aadhya", "Aaradhya", "Ananya", "Pari", "Anika",
    "Navya", "Diya", "Myra", "Ira", "Sara", "Ahana", "Kiara", "Prisha",
    "Avni", "Meera", "Riya", "Sneha", "Pooja", "Neha", "Priya", "Swati",
    "Kavya", "Tanvi", "Divya", "Shreya", "Aishwarya", "Lakshmi", "Sita",
    "Radha", "Geeta", "Anjali", "Sunita", "Rekha", "Padma", "Savitri",
    "Kamala", "Indira", "Nandini", "Deepika", "Rani", "Lata", "Usha",
    "Shalini", "Bhavana", "Madhuri", "Pallavi", "Rashmi", "Vaishali",
]

LAST_NAMES = [
    "Sharma", "Verma", "Gupta", "Singh", "Kumar", "Patel", "Reddy",
    "Rao", "Nair", "Menon", "Iyer", "Shah", "Joshi", "Desai", "Mehta",
    "Chopra", "Malhotra", "Kapoor", "Bhat", "Pillai", "Das", "Ghosh",
    "Mukherjee", "Chatterjee", "Banerjee", "Sen", "Bose", "Dutta",
    "Agarwal", "Mishra", "Pandey", "Tiwari", "Dubey", "Srivastava",
    "Saxena", "Rastogi", "Chauhan", "Yadav", "Thakur", "Rajput",
    "Naidu", "Kulkarni", "Patil", "Shinde", "Jadhav", "Pawar",
    "Kaur", "Gill", "Sidhu", "Dhillon", "Bedi", "Walia", "Bajwa",
]

CITIES = [
    ("Mumbai", "Maharashtra"), ("Delhi", "Delhi"), ("Bangalore", "Karnataka"),
    ("Hyderabad", "Telangana"), ("Chennai", "Tamil Nadu"), ("Kolkata", "West Bengal"),
    ("Pune", "Maharashtra"), ("Ahmedabad", "Gujarat"), ("Jaipur", "Rajasthan"),
    ("Lucknow", "Uttar Pradesh"), ("Chandigarh", "Punjab"), ("Kochi", "Kerala"),
    ("Bhopal", "Madhya Pradesh"), ("Indore", "Madhya Pradesh"),
    ("Visakhapatnam", "Andhra Pradesh"), ("Nagpur", "Maharashtra"),
    ("Coimbatore", "Tamil Nadu"), ("Thiruvananthapuram", "Kerala"),
    ("Patna", "Bihar"), ("Guwahati", "Assam"), ("Mysore", "Karnataka"),
    ("Varanasi", "Uttar Pradesh"), ("Surat", "Gujarat"), ("Vadodara", "Gujarat"),
]

STREETS = [
    "MG Road", "Gandhi Nagar", "Nehru Street", "Station Road", "Park Avenue",
    "Main Street", "Civil Lines", "Rajaji Nagar", "Anna Salai", "Brigade Road",
    "Linking Road", "Hill Road", "Ring Road", "Church Street", "Temple Street",
    "Market Road", "Lake Road", "Residency Road", "Cantonment Area",
    "Jubilee Hills", "Banjara Hills", "Koramangala", "Indiranagar",
    "Sector 17", "Sector 22", "Phase 5", "Block C", "Green Park",
]

EMAIL_DOMAINS = [
    "gmail.com", "yahoo.co.in", "outlook.com", "rediffmail.com",
    "hotmail.com", "protonmail.com", "icloud.com",
]


def _random_phone():
    """Indian mobile: +91 followed by 10 digits starting with 6-9."""
    prefix = random.choice(["6", "7", "8", "9"])
    return f"+91 {prefix}{random.randint(100000000, 999999999)}"


def _random_email(name: str, pid: str):
    """Generate a plausible email from the patient name."""
    base = name.lower().replace(" ", ".").replace("..", ".")
    suffix = pid[-4:]  # last 4 chars of patient_id for uniqueness
    domain = random.choice(EMAIL_DOMAINS)
    return f"{base}{suffix}@{domain}"


def _random_address():
    house = f"{random.randint(1, 999)}/{random.choice('ABCDEFGH')}"
    street = random.choice(STREETS)
    city, state = random.choice(CITIES)
    pin = random.randint(100000, 999999)
    return f"{house}, {street}, {city}, {state} - {pin}"


def _random_admission_date():
    """Random date between 2022-01-01 and 2026-02-01."""
    start = datetime(2022, 1, 1)
    end = datetime(2026, 2, 1)
    delta = (end - start).days
    d = start + timedelta(days=random.randint(0, delta))
    return d.strftime("%Y-%m-%d")


def main():
    client = MongoClient(MONGO_URI)
    db = client[DB_NAME]
    col = db.patients

    # Get all patients without patient_name
    patients = list(col.find(
        {"$or": [{"patient_name": {"$exists": False}}, {"patient_name": None}]},
        {"_id": 1, "patient_id": 1, "gender": 1}
    ))
    total = len(patients)
    if total == 0:
        print("All patients already have personal details. Nothing to do.")
        return

    print(f"Seeding personal details for {total} patients...")

    ops = []
    for i, p in enumerate(patients):
        gender = p.get("gender", "Male")
        pid = p.get("patient_id", f"P{i}")

        if gender == "Female":
            first = random.choice(FIRST_NAMES_FEMALE)
        else:
            first = random.choice(FIRST_NAMES_MALE)
        last = random.choice(LAST_NAMES)
        full_name = f"{first} {last}"

        phone = _random_phone()
        email = _random_email(full_name, pid)
        address = _random_address()
        emergency_contact = f"{random.choice(FIRST_NAMES_MALE + FIRST_NAMES_FEMALE)} {random.choice(LAST_NAMES)} — {_random_phone()}"
        admission_date = _random_admission_date()

        ops.append(UpdateOne(
            {"_id": p["_id"]},
            {"$set": {
                "patient_name": full_name,
                "phone": phone,
                "email": email,
                "address": address,
                "emergency_contact": emergency_contact,
                "admission_date": admission_date,
            }}
        ))

        if len(ops) >= 200:
            result = col.bulk_write(ops)
            print(f"  Updated {i + 1}/{total} patients ({result.modified_count} modified)")
            ops = []

    if ops:
        result = col.bulk_write(ops)
        print(f"  Updated {total}/{total} patients ({result.modified_count} modified)")

    # Verify
    sample = col.find_one({"patient_name": {"$exists": True}}, {"_id": 0})
    print(f"\nDone! Sample patient:\n{sample}")


if __name__ == "__main__":
    main()


================================================================================
--- FILE: .\scripts\__init__.py ---
================================================================================
# Utility scripts
